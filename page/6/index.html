<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


  <meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">

<script>
    (function(){
        if(''){
            let localStoragePasswdKey = '' + '_last_passwd';
            function checkPassword(password) {
                password = password == null ? null : password.trim();
                if (password !== '') {
                    if (password != null) {
                        // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
                        alert('Error!');
                    }
                    if (history.length > 1) {
                        history.back();
                    } else {
                        window.location.href = "about:blank";
                    }
                } else {
                    localStorage.setItem(localStoragePasswdKey, password);
                }
            }

            var password_verify_on_local = false;
            const hostname = window.location.hostname;
            if (password_verify_on_local || (!(hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1" || hostname.startsWith("192")))) {
                const lspk = localStorage.getItem(localStoragePasswdKey) || "";
                if (lspk !== '') {
                    var password = prompt('Open Sesame');
                    checkPassword(password);
                }
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">





















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="🚙 🚗 💨 💨 If you want to create a blog like this, just follow my open-source project, &quot;hexo-theme-neo&quot;, click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari,">
<meta property="og:type" content="website">
<meta property="og:title" content="🚙">
<meta property="og:url" content="https://hulinhong.com/page/6/index.html">
<meta property="og:site_name" content="🚙">
<meta property="og:description" content="🚙 🚗 💨 💨 If you want to create a blog like this, just follow my open-source project, &quot;hexo-theme-neo&quot;, click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari,">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="🚙">
<meta name="twitter:description" content="🚙 🚗 💨 💨 If you want to create a blog like this, just follow my open-source project, &quot;hexo-theme-neo&quot;, click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari,">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: false,
    mediumzoom: true,
    darkmode_js: false,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":188,"transition":{"header":"fadeIn","menu":"fadeIn","logo":"fadeIn","post_block_else":"fadeIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"fadeIn","footer":"fadeIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>🚙 - 💨 💨 💨</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">🚙</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">💨 💨 💨</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <div class="site-search-div">
    <button class="search-icon" id="search-button">
      <i class="fa fa-search"></i>
    </button>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </div>


<script type="text/javascript" id="local.search.active">
    {/* var inputArea       = document.querySelector("#local-search-input");
    inputArea.onclick   = function(){ getSearchFile(); this.focus(); }
    inputArea.onkeydown = function(){ if(event.keyCode == 13) return false } */}
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/teach_you_to_write_jokes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/teach_you_to_write_jokes/" itemprop="url">教你写笑话</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-02-14T21:53:26+00:00">
                02-14-2023
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Misc/" itemprop="url" rel="index">
                    <span itemprop="name">Misc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　几乎很少有什么关于幽默创作方面的理论，你也很难找到这方面的书籍。对于幽默，几乎就是凭借着个人的天赋，比如说赵本山、郭德纲、周星驰，想弄出好的段子，几乎就是凭借这些人的个人能力。你如果问他们，你们是怎么想出好笑话的，他们也是莫名其妙，他们会这样说：灵机一动、灵感、一拍大腿、脑子里电光一闪，总之，他们不会说出具体的方法来。一些相声老师傅会口耳相传一些做包袱的手法，但那些方法听起来就有些可笑。<br>　　中国的幽默理论虽然很少，但西方却一直有研究幽默的传统。从亚里士多德到康德两千多年里，产生了二百多种幽默理论。其中著名的有三种，它们分别是优越论、宽慰论、乖讹论。当今的幽默理论界占主流地位的有两种理论，分别是脚本转换和乖讹论。脚本理论说的是笑话都是由两个脚本构成的，总是会由一个脚本转化到另一个脚本。乖讹的意思是与众不同的事物，乖讹论说的是笑话总是由这些与众不同的事物构成。我是在前人的理论基础上，将幽默理论向前推进了一大步。我的发明亮点是，前人虽然知道乖讹很重要，每个笑话里都有它的存在，但它究竟在笑话里起什么作用却搞不清楚。我首先提出了乖讹不是死物，它是活物。它可以实现转换，由一个乖讹转换成为另一个乖讹。从作者得到一个幽默素材开始，幽默素材就是一个乖讹，叫素材乖讹。作者将素材乖讹转换成为一个作品乖讹，我们看到的幽默作品中的乖讹，就是有作者用一个幽默素材转化而来的。我的这套幽默理论叫做乖讹推导理论，意思是乖讹总是会由一个乖讹推导出另外一个乖讹。我的理论完美的诠释了乖讹论，又巧妙的将脚本转换理论纳入我的理论当中，使它成为了乖讹推导的一种方式。</p>
<p>　　本文由于采用了许多的专业术语以及字母和公式，让读者读起来有些乏味。而且许多读者会认为，我也不想成为段子手，学这些写笑话的方法有什么用！我想对你说的是：你如果这样认为，那你就大错特错了。西方为什么那么热衷于幽默理论的研究？象亚里士多德、康德这种顶级哲学家都参与其中，难道他们只是为了研究写笑话的方法？难道这些人也是穷的需要向杂志社投些小段子，来获得一些稿费？其实幽默是人类思维的一种重要形式，与其说这些人在研究写笑话的方法，不如说他们在试图破解人类思维的奥秘。就以我的脚本转换理论为例，它不止适用于幽默，它更适用于文学的点子与计谋，科学的顿悟，发明和广告的创意。它其实就是把人类的最高思维形式创造力给公式化了，以前只有几个天才能够想到的创意，现在只要运用我的公式，一个普通人也可以把它推导出来。如果你是一个电脑高手，将我的推导理论编制成电脑程序，你就可以得到一台拥有创造力的超级电脑，人类一直梦想的研制出像人一样聪明的机器人的想法，其实很快就可以实现了。<br>　　以上所说的内容都是我的一些想法，但你不觉得我的想法很有道理吗？我希望你仔细的阅读全文，看看我的乖讹推导理论可不可以将人类的创造力公式化，如果你也觉得可以，我希望你和我站在一起，为了伟大的梦想而奋斗。<br>　　本文的第一章介绍了脚本理论和乖讹论，简单的阐述了虚假相同差异关系对的概念。第二、三、四章正式推出我的乖讹推导理论以及各种乖讹推导的推导公式。第五章讲述了如何得到素材乖讹。<br>　　关键词：脚本转换、乖讹论、乖讹推导理论、狭义乖讹推导理论、真实相同差异关系对简称真对、虚假相同差异关系对简称假对、乖讹点B。</p>
<h1 id="第一章脚本理论"><a href="#第一章脚本理论" class="headerlink" title="第一章脚本理论"></a>第一章脚本理论</h1><h2 id="一语义脚本理论"><a href="#一语义脚本理论" class="headerlink" title="一语义脚本理论"></a>一语义脚本理论</h2><p>　　脚本这个概念起源于心理学，后来应用于认知学和人工智能。脚本不同的人有不同的称谓，有人称框架，有人称图示，还有人称场景。脚本指的是人们心里的认知框架。比如说动物的脚本包括有皮肤、能活动、吃食物、呼吸空气;鸟的脚本包括有翅膀、有羽毛、能飞等。总之,一个符号、一种物体等均可以看成是一种脚本。<br>　　Raskin首先应用脚本理论解释幽默，他于1985年提出了语义脚本理论。他的想法主要有三点。<br>　　1笑话是由两个脚本构成的。<br>　　2这两个脚本是相互对立的。<br>　　3通过触发词的作用，可以从一个脚本转换成另一个脚本，即所谓的脚本转换或框架转移。</p>
<p>　　例</p>
<p>　　“医生在家吗”？一位病人用带有支气管的病变的声音低声询问。“不在”，医生的年轻漂亮的老婆低声回答道，“直接进来吧”<br>　　这个笑话里，第一个脚本是病人看病的脚本，第二个脚本是通奸的脚本，触发词是直接进来吧。通过触发词，第一个脚本直接转换成为第二个脚本。<br>　　还可以举出其他的例子</p>
<p>　　例</p>
<p>　　你才是猪<br>　　某日老李一个人在山路上开车，正当他倘佯在山区美丽风景时，突然迎面开来一辆计程车，而且司机还摇下窗户对他大骂一声猪。此时老李越想越纳闷也越来越气，于是他也摇下车窗回头大骂：“你才是猪！”才刚骂完，老李便迎头撞上一群过马路的猪。<br>　　这个笑话里，第一个脚本是别人骂老李是猪，老李和他对骂。第二个脚本是真的碰上了一群猪。</p>
<p>　　例</p>
<p>　　某日,我开了一辆面包,一开奔驰的追上我,问:兄弟,开过大奔吗?把我气坏了，一踩油门就开走了，谁知他追上我，又问：兄弟,开过大奔吗?气死我也！我又开走了，在前面，他超了我，撞树上去了。我跑过去，问：兄弟,开过大奔吗?他带着哭腔答：我就是因为没开过才问你刹车在那，你TMD咋不告诉我啊！<br>　　这个笑话里，第一个脚本是开奔驰的人向开面包的人炫富，第二个脚本是问他奔驰的刹车在那？</p>
<h2 id="二如何实现脚本转换"><a href="#二如何实现脚本转换" class="headerlink" title="二如何实现脚本转换"></a>二如何实现脚本转换</h2><p>　　这个才是许多作者真正想知道的问题！按照Raskin的观点，触发词是实现脚本转换的关键。但实际上，双关语才是最重要的。在《你才是猪》的笑话里，猪是一个双关语，它的一个含义是骂人的脏话，另一个含义是一种动物。作者利用了这两种不同的意思，利用脏话的意思构建了一个骂人的脚本，利用动物的意思构建了一个交通事故的脚本。脚本转换的基础是误会，利用双关语字面相同的特点，分别构制了两个脚本。第二个脚本隐藏在第一个脚本中间，通过触发词的作用，实现了脚本的突然转换。在开奔驰的笑话里，双关语是“你开过奔驰吗”。“你开过奔驰吗”有两个含义，一个是你开不起奔驰吧。作者利用这个意思构制了第一个脚本，开奔驰的司机戏弄一个开面包的司机。“你开过奔驰吗”的另一个含义是你知道奔驰怎么开吗？作者利用这个意思构制了问奔驰刹车在哪的脚本另一个脚本。脚本转换始终是以误会为基础的，作者欺骗的其实是读者，在读者还没有反应过来的时候，突然从一个脚本转换成另一个脚本。</p>
<p>　　例</p>
<p>　　说好一起到白头，你却偷偷焗了油。<br>　　这个幽默语句中，“白头”一个是一个双关语，一个意思是白头偕老，作者利用这个意思构制了第一句白头偕老的脚本。另一个意思是真正的白头发，作者利用这个意思同焗油构制了另一个脚本。形成了脚本的转换。</p>
<p>　　例</p>
<p>　　护士对正在喝酒的病人说：“小心肝”。病人猥琐的对护士说：“小宝贝”。<br>　　这个段子里“小心肝”是一个双关语，护士的意思是小心你的肝。而病人理解为昵称的小心肝，构制了一个猥琐的脚本。</p>
<p>　　例</p>
<p>　　赵本山的一个段子，记者采访一位大妈：“大妈，你对过年燃放烟花爆竹怎么看。”大妈说：“问我怎么看啊，我爬窗户看。”<br>　　这个段子里，“看”是一个双关语,记者的看是看法的意思，而大妈理解的是如何的观看，作者利用两个意思分别构制了两个脚本，实现脚本转换。<br>　　如果不利用双关语可以进行这种脚本转换吗？当然可以了！</p>
<p>　　下面我再举一个例子</p>
<p>　　有一个囚犯逃离了关了他１５年的监狱。他越狱后，闯入了一间民宅，看到了一对年轻的夫妻躺在床上。他把那位丈夫的赶下床，绑在椅子上，把太太绑在床上，他上了床，亲吻那太太的脖子，然后就进去了洗手间。当那逃犯在洗手间的时候，丈夫跟他的太太说：“听著，这个男的是囚犯，看看他的衣服就知道！他可能被关很久，而且很久没碰过女人了，假如他想要**，千万不要抵抗，也不要抱怨，就让他做他想做的事，让他满足就好。这个人非常的危险，假如让他生气的话，他可能会把我们杀了。”<br>　　这时候他太太说：“我很高兴你这样想，没错，他很久没碰女人了，但是他刚才不是在亲我的脖子，他是在我的耳边小声的说他觉得你很性感，问我洗手间里面有没有放润滑液。坚强点，亲爱的，我爱你！”<br>　　在这个笑话里，第一个脚本是一个逃犯想强奸妻子，第二个脚本是逃犯是同性恋，想强奸的是丈夫。这里面没有双关语，构制两个脚本的两个概念是“强奸犯”和“同性恋强奸犯”。两者之间看起来是相同的，让读者产生了误会，实现了脚本转换。</p>
<p>　　例</p>
<p>　　人家是在擦玻璃呢<br>　　老王对哥们说：“难道今天我走了桃花运了?”<br>　　哥们问：“怎么了?”<br>　　老王说：“对面楼有个美女挥舞白手帕，对我挥了一早上了。”<br>　　哥们伸头一看说：“尼玛的，人家是在擦玻璃呢。”<br>　　在这个笑话里，第一个脚本是美女冲老王挥手，第二个脚本是美女在擦玻璃。挥手和擦玻璃看起来是相同的，让人引起误会，实现了脚本转换。<br>　　读到这里，聪明的读者已经发现了其中的规律性，是的，这就是我要推出的一个新的概念，“虚假相同差异关系对”</p>
<h2 id="三虚假相同差异关系对"><a href="#三虚假相同差异关系对" class="headerlink" title="三虚假相同差异关系对"></a>三虚假相同差异关系对</h2><p>　　如果两者之间看起来相同或听起来相同或某一部分相同，而两者之间本质上是不同的，那么我们就把这两者称为虚假相同差异关系对。<br>　　双关语的两个不同含义就是一对虚假相同差异关系对。例如双关语“猪”中，骂人的脏话猪和动物的猪就是一对虚假相同差异关系对。而在“你开过奔驰吗”中，炫富的“你开过奔驰吗”和你会开奔驰吗？形成一对虚假相同差异关系对。在双关语“白头”中，一个含义白头偕老和另一个含义白头发之间形成一个虚假相同差异关系对。虚假相同差异关系对这个名词太过绕嘴，主要是为了让读者理解它的真正含义。两者之间有相同的部分，也有差异的部分，为什么叫虚假呢，主要是为了将来还要推出一个真实相同差异关系对。为了省事，以后简称虚假关系对。<br>　　语言文字形成的关系对通常都是虚假关系对，比如说多音字，长（chang)和长(zhang）之间。两个字是相同的，但读音是不同的，含义也是不同的。</p>
<p>　　例</p>
<p>　　南京市长（chang)江大桥南京市长（zhang)江大桥<br>　　利用多音字，形成了另一个脚本。<br>　　我的家乡是尚志市，尚志市曾经自号为雪都，有一年的广告宣传语是“雪都欢迎您”。一个外地人看了好生感动：“你们尚志人太热情了，连雪都欢迎我”。他没有分清楚都du和都dou。<br>　　不只是语言文字可以形成虚假关系对，形态动作也可以，甚至许多抽象的道理也可以。在前面的擦玻璃的笑话里，擦玻璃和挥手之间就是一对虚假关系对，两者之间的相同点是看起来很像，不同点是各有不同的意义。而在同性恋强奸犯的笑话里，强奸犯和同性恋强奸犯构成虚假关系对，两者之间外表看起来没有什么不同，但是本质上却又重大的不同。</p>
<p>　　例</p>
<p>　　公交车上，一个青年在嚼着口香糖。坐在他对面的一个老头突然说：“你别说了，我听不清，听不清。<br>　　这个笑话里，嚼口香糖和说话之间；形成了一个虚假关系对。两者看起来是相同的，但本质上却又重大的不同。作者利用这个特点，形成了两个脚本，以相同点为轴，进行脚本转换。<br>　　现在我们知道，要想实现脚本转换，就需要一个虚假关系对。利用关系对的两个不同的概念构制两个不同的脚本，以相同点为轴，形成脚本转换。</p>
<h2 id="四同一律"><a href="#四同一律" class="headerlink" title="四同一律"></a>四同一律</h2><p>　　我们利用虚假关系对的两个不同的概念，分别构制两个脚本，从而形成了脚本转换的手法。如果把虚假关系对中的两个不同概念放在一个脚本里，那会是一个什么样子呢？<br>　　同一律是一个逻辑学的概念，逻辑学有三大基本的原则。只有符合这三条基本的原则，逻辑推理才是成立的，否则，逻辑不成立。这三条基本原则是：同一律，矛盾律，排中律。同一律概念是在同一思维过程中，必须在同一意义上使用概念和判断，不能在不同意义上使用概念和判断。<br>　　只有符合同一律，逻辑才是成立的。而幽默恰恰总是违反了同一律，两个不同概念肆意的放在一个脚本里进行比较，作用，印证。不符合逻辑，却有了幽默的效果。</p>
<p>　　例</p>
<p>　　兜比脸还干净<br>　　兜的干净和脸的干净是一对虚假关系对，都是干净，但是概念确是不同的。兜的干净指的是兜里什么也没有，而脸的干净指的是脸上没有灰尘。两个不同的概念放在一起进行比较，逻辑上是没有意义的，但幽默效果十分明显。</p>
<p>　　例</p>
<p>　　一个男孩去商店里买飞机模型，售货员对他说：“你的钱是假的。”小孩分辨道：“你的飞机不也是假的吗？<br>　　这个笑话里，飞机的假和钱的假不是一个概念，小孩将它们混为一谈，用来进行狡辩。</p>
<p>　　例</p>
<p>　　自从得了精神病以后，整个人都精神多了。<br>　　精神病和精神是一对虚假关系对，字面上是相同的，但是概念上是不同的。把两者混为一谈，达到幽默的效果。</p>
<p>　　例</p>
<p>　　儿子哭着对爸爸说：“他们都说我傻，我真的傻吗？”爸爸抚摸着儿子的头说：“你怎么会傻呢，傻孩子。”<br>　　傻孩子和傻是一对关系对，傻孩子是昵称，并不是真的傻。把这两个不同的概念放在一起，起到了一个自相矛盾的作用。<br>　　脚本转换的手法是利用虚假相同差异关系对中两个不同的概念，分别构制两个脚本。以相同点为轴，通过触发词的作用，突然进行脚本转换。违反同一律的手法是，将虚假相同差异关系对中的两个不同的概念放在同一个脚本里进行比较，印证，相互作用。虚假相同差异关系对在幽默中有着举足轻重的作用，或者可以说，一个关系对的好坏，就决定了一个段子的好坏。但我们如何能得到一个好的关系对呢？这就是我们在下面章节里要讨论的内容。</p>
<h2 id="五乖讹论"><a href="#五乖讹论" class="headerlink" title="五乖讹论"></a>五乖讹论</h2><p>　　幽默理论研究渊源流长，从亚里士多德开始，至今已有两千多年的历史。幽默理论层出不穷，其中以三大理论最为著名，它们分别是优越论，宽慰论，乖讹论。其中乖讹论以其独特的研究视角最为深入人心，今天乖讹论依然是幽默研究的主流。<br>　　乖讹论也被称为不和谐理论。在当代幽默心理面研究中占主导地位的乖讹论，是对幽默和笑的研究中最具影响力的一派理论。有相当久远的历史。乖讹这一概念大概可以追溯到古希腊时代，最起码始于文艺复兴时期。之后的康德和叔本华也曾从乖讹的角度提出了自己的理论。Beattie对乖讹的定义被广为引用，他说:“两个或更多不一致、不适合、不协调的部分或情况，在一个复杂的对象或集合中统一起来，或以一种头脑能注意到的方式获得某种相互关系，笑便源出于此。”18世纪的康德被认为是第一个从乖讹的角度为幽默下了完整定义的人。他指出，幽默来自于“从期待到期待落空的突然转换”。叔本华在给笑的定义中则明确地提到了乖讹/不和谐：“在每一个事例中，笑的原因不过是突然感觉到一个概念和借助这一概念表现的现实事物之间的不和谐，而笑本身正是这一不和谐的表现。<br>　　那么什么是乖讹呢？乖讹指的是不正常的，不和谐的，与众不同的。在我们的大脑中存在着一个对万事万物正常状态的框架，即所谓的脚本。当出现一个与正常脚本不同事物或现象的时候，我们就认为它是乖讹的。例如，正常人的身高是170左右，而当出现一个身高220的姚明的时候，我们就认为姚明是一个乖讹。例如，美国总统都是白人，当出现一个黑人总统奥巴马时，我们就认为他是乖讹的。乖讹是一个相对的概念，与它相对的总有一个正常的概念。乖讹也是分不同人群的，现代人和古代人对乖讹的认识就是不同的，我们会认为古代人留辫子是一个乖讹。而古代人则会认为我们留短发是一个乖讹。<br>　　康德说过：“两个或更多不一致、不适合、不协调的部分或情况，在一个复杂的对象或集合中统一起来，或以一种头脑能注意到的方式获得某种相互关系，笑便源出于此。”<br>　　一个不和谐就代表一个乖讹，一个笑话里通常会有两个或两个以上的乖讹，这些乖讹之间有什么关系呢？<br>　　我在乖讹的研究方面比前人深入一些，下面就直接引入我的研究理论了，我的幽默理论叫做“乖讹<br>　　推导理论”</p>
<h2 id="六乖讹推导理论"><a href="#六乖讹推导理论" class="headerlink" title="六乖讹推导理论"></a>六乖讹推导理论</h2><p>　　幽默创作不是无中生有的，它也需要一个写作素材，这个写作素材必须是一个乖讹，我把它叫做素材乖讹。或者可以这么理解，幽默创作其实就是一个对素材乖讹的推导过程。作者把素材乖讹推导成一个新的乖讹，这个乖讹叫做作品乖讹，作品乖讹和素材乖讹整体上才能算作一个笑话。比如说一个人走着走着突然摔了一跤，这看起来很好笑，但这只是一个素材乖讹，算是一个滑稽，称不上是幽默。幽默必须是一个推导公式，由一个已知的素材乖讹推导出一个新的乖讹。素材乖讹必须是作者和读者之间的一种共识，大家都承认它的存在或想象中的存在。读者欣赏幽默的过程，其实就是看着作者对素材乖讹的推导过程，如何利用一个已知乖讹推导出一个新的乖讹的过程。现在大家应该明白了为什么一个新闻出来了，会聚集大量的段子手进行pK。一个新闻就是一个好的素材乖讹，利用这个乖讹，段子手可以创作出大量的段子。生活中的幽默也是一样，总会出现一个乖讹事件，一个擅长幽默的人就会抓住这个乖讹，突然搞出一句爆笑的语言。如果一个人对你说：‘你能不能用一句话把大家给逗笑了。”这是一个很荒谬的提法，幽默创作不可能无中生有的，它需要有一个素材乖讹，作者创作的过程其实就是对这个素材乖讹推导的过程。一个好的幽默创作者，他首先是一个善于发现素材乖讹的人，其次才是一个善于进行乖讹推导的人。</p>
<p>　　那么应该如何对素材乖讹进行推导呢，下面我们就来具体研究一下乖讹推导的方法。</p>
<p>　　一个乖讹通常可以分解成三种状态，真实相同差异关系对，虚假相同差异关系对，以及一个乖讹作用生成另一个乖讹，利用另一个乖讹形成相同差异关系对。下面我们具体的对三种方法进行分析。</p>
<h1 id="第二章真实相同差异关系对"><a href="#第二章真实相同差异关系对" class="headerlink" title="第二章真实相同差异关系对"></a>第二章真实相同差异关系对</h1><p>　　乖讹是一个相对的概念，一个乖讹总是有一个和它相对的正常的概念，我把乖讹和与它相对正常的概念称为一对真实相同差异关系对。比如说姚明是一个乖讹，与他相对正常的是普通人，姚明与普通人构成了一对真实相同差异关系对。比如说哑语是一个乖讹，与它相对正常的是正常的语言，哑语与正常的语言之间构成了一对真实相同差异关系对。为了简便起见，以后我会把真实相同差异关系对简称为真对，虚假相同差异关系对简称为假对。</p>
<p>　　当我们得到一个素材乖讹的时候，很容易就把它化解为一个真对，如何对一个真对进行推导呢？</p>
<p>　　一个乖讹与它相对正常的概念之间总会有一个差异，我把这个差异叫做乖讹点。比如说姚明和普通人之间的差异是高度，高度就是这个真对的乖讹点。比如说煎饼是一个乖讹，它和普通食物之间的差异是它特别的薄，薄就是煎饼和普通食物之间真对的乖讹点。</p>
<p>　　我把正常的概念记做A，乖讹点记做B,一个乖讹可以记做A+B。<br>　　A会与周围的物体或者环境发生作用，周围的物体或环境记做C。<br>　　单单有C显然还不够，C不会和B发生作用，A与C发生作用，得到的结果是E,而A+B与C发生作用得到的结果也是E。两个结果是相同的，也是毫无意义的。<br>　　我们还需要一个点D，D是C的特殊情况，也可以说是C的乖讹，记做C+D。D是一个特殊的点，它即会和A发生作用，也会和B发生作用。而且对两者之间的作用是完全不同的，D或者是允许A否定B,或者说允许B否定A。<br>　　造成的结果是A与C+D之间发生相互作用，得到的结果是E，A+B与C+D发生相互作用得到的结果是F。F与E之间产生的重大的差异。也就是说A与A+B之间的差异推导出了E和F之间的差异。我把这个公式叫做狭义乖讹推导公式。</p>
<p>　　例</p>
<p>　　医生：你的病需要进行隔离治疗，以后你只能吃煎饼了。<br>　　病人：吃煎饼对我的病情有帮助吗？<br>　　医生：不是，这是唯一能从门缝里塞进来的食物。<br>　　在这个笑话里，A是正常的食物，A+B是煎饼，B是乖讹点，它特别的薄。遇到的环境乖讹C+D是一个封闭的房间，只留一个小门缝。D点会否定A，普通的食物塞不进来，D点会肯定A+B,只有煎饼能塞进来。在幽默创作中，作者首先得到的是一个素材乖讹A+B，这时需要构思的是与乖讹点B发生相互作用的环境乖讹D点。再把D点构制成可以与A发生作用的C+D。</p>
<p>　　例</p>
<p>　　一个人到游泳馆里对经理说：“我想应聘你这里的救生员。”经理问他：“你会游泳吗？”他说不会。经理大怒道：“你不会游泳，你当什么救生员，你是逗我玩吗？”他说：“你们游泳池的水深两米，我的身高是两米二，我不会游泳也淹不死啊！”<br>　　这个笑话肯定是因姚明而构制的，这里普通人是A，姚明是A+B，B点是姚明与普通人之间的高度差，环境是水池C，特殊的水深是D，这里的水深D点一定要是两米，如果水深是一米五，姚明和普通人都不会被淹死，这是没有意义的。如果水深是两米五，姚明和普通人都会被淹死，这也是没有意义的。只有水深是两米的时候，普通人会被淹死，姚明却不会，姚明和普通人的身高差被推导成为普通人会被淹死，姚明却不会。这里如果把姚明换成是一个侏儒，依然可以构制成一个笑话。</p>
<p>　　例</p>
<p>　　女巫追到了黑森林里，白雪公主带着七个小矮人迅速逃命，跑着跑着，前面出现了一条大河。幸好河水不深，刚好到白雪公主的腰部，白雪公主忍着冰冷刺骨的河水，逃到了对岸，回头一看，妈呀，七个小矮人被淹死了！<br>　　小矮人与普通人之间的乖讹点B依然是高度差，水的高度D依然需要控制，需要控制在可以把小矮人淹死，普通人却不会。<br>　　研究这套理论的时候，我正在读《失控》这本书，给我很大的灵感。达尔文创立进化论以来，立即以它独特的观点深入人心，到了今天，人们不止将进化论应用于生物界，在自动化控制电脑编程，复杂系统研究等诸多领域，人们会将优胜劣汰应用到方方面面。就好像一只小怪兽，由于基因突变，它产生了。如果环境不改变，那它并没有什么发展，只不过是和正常的有些不同而已嘛，并没有什么了不起的。但是环境发生了改变，变得只适合小怪兽生存，而把正常的都干掉。这是人们才发现小怪兽的伟大。我们也可以把这个理论推广到万事万物，任何事物当出现一个它的乖讹的时候，人们总是会把它和正常事物放在一起进行比较，去面对正常事物应该面对的环境。当环境很正常的时候，人们不会注意这个乖讹的与众不同，一旦环境改变的时候，环境会变得否定正常现象而肯定乖讹，这时人们才发现乖讹的与众不同。我们以金庸小说的屠龙刀为例，屠龙刀是一个乖讹，它相对于普通刀的乖讹点是削铁如泥。当它和普通刀一样，面对的环境只是萝卜豆腐、鸡鸭鱼肉的时候，它和普通刀没有什么区别。当面对的环境是铜铁的时候，普通的刀已经无能为力了，这时才凸显出屠龙刀的威力。</p>
<h2 id="为什么叫狭义乖讹推导理论呢？"><a href="#为什么叫狭义乖讹推导理论呢？" class="headerlink" title="为什么叫狭义乖讹推导理论呢？"></a>为什么叫狭义乖讹推导理论呢？</h2><p>前文我们提到，素材乖讹可以分解成不同的关系对，这些关系对又<br>　　都可以进行推导，所以会有很多种不同的推导方式。而这些方式有些只适用于文学，甚至有些只适用于幽默。只有狭义乖讹推导公式既适用于文学，也适用于科学。它是人们进行思维活动的时候的一种实实在在的推理方式。逻辑学有三大推理方法，演绎推理、归纳推理，类比推理。而狭义乖讹推理是区别于这三种方式的一种新的推理方法，它更适用于人们进行创造性思维。如果你对思维或者对智慧很感兴趣，我希望你能掌握并熟练运用这种方法。我可以大言不惭的告诉你，如果你熟练了这种思维技巧，至少可以让你的智商提高二十个百分点。狭义乖讹推导公式必须是有一个真实相同差异关系对，B点必须和D点发生相互作用，所得到的E和F之间的差异必须是有合理性的。</p>
<p>　　狭义乖讹推导公式在文学中应用非常广泛，尤其是在故事当中。例如在金庸的《飞狐外传》中，主人公胡斐和众群侠被困在铁制的密室里，敌人又在密室的底部点上火，想把群侠给烤死。当时只有一个小孔与外界相连，群侠身材都很高大，很难从小孔中钻出去，只有胡斐当时只有十三岁，身材矮小，从小孔中钻了出去，杀死了敌人，解救了群侠。<br>　　这里胡斐与群侠相比是一个乖讹A+B，群侠是A，乖讹点B是身材矮小。作者构思了一个可以和乖讹点B发生作用的D点，D点是一个小孔，D可以否定群侠A，又可以肯定乖讹胡斐。<br>　　在《笑傲江湖》中，令狐冲只会武功，没有内力。遇到了一个以琴音作为攻击武器，专门攻击人的内力。令狐冲由于根本没有内力，所以免遭攻击，战胜了对手。<br>　　这里的乖讹点B是没有内力，根据乖讹点，作者构制了可以和B相互作用的D点。D是专门攻击人的内力，D可以否定普通人，却可以肯定令狐冲。</p>
<p>　　有一个关于曾国藩的段子，说曾国藩很笨，背书总是背很多遍也不会。一天，他在家里背书。有一个贼摸到他家里，躲在房梁上，只等他睡着了，好去偷东西。只见曾国藩背一小段文章，背了两个时辰还是不会，贼实在是忍不了了，从梁上跳了下来。对曾国藩说：“你这么笨，还当什么读书人。”说着，把曾国藩背的文章从头至尾背了一遍，然后扬长而去。<br>　　这里的乖讹点B是时间长，作者构制了一个D点是一个急等时间的贼。<br>　　狭义乖讹推导理论是可以反推的，在文学创作中，作者通常是得到一个素材乖讹，把它化解成一个真实相同差异关系对，找出乖讹点，通过乖讹点，设计出一个与它相互作用的D点。从而构制成一个段子或者是故事。而在科学发明中，这个乖讹是根本不存在的。研究者通常遇到的是一个困难，C+D与A相互作用得到的结果是E,E是一个困难，为了解决这个困难，需要找到一个A+B，A+B与C+D相互作用，得到的结果是F，F与E是不同的，从而解决了困难。研究者其实求解的是B。例如在爱迪生发明灯泡的过程中，遇到的一个困难是，在两千度的高温下，灯丝就会熔断。为了解决这个问题，必须找到灯丝的乖讹，让它在高温下不会熔断。爱迪生解决了这个问题，研究出了一种炭化的灯丝，在高温下不会熔断，从而解决了问题。</p>
<p>　　我曾经搞过一个发明，新型筷子。<br>　　筷子是中国人的餐具，非常实用。但使用它需要很大的技巧，儿童以及外国人就很难使用筷子。这里就是一个困难，为了解决这个困满，就需要对筷子进行改进。我把筷子的尾部用弹性材料连接，把筷子做成一个U型，更像是一个夹子，使用起来非常简便，从而解决了困难。<br>　　发明其实是研究者研究出了一个新的乖讹，把它放在困难当中，解决了困难。<br>　　在解决困难的模式中，会把C+D与A发生作用，得到E设置为一个困难。而把C+D与A+B作用得到结果F视为解决困难。在这个模式中，D是否定A，肯定B的。而在幽默中，更喜欢的是D否定B。</p>
<p>　　例</p>
<p>　　印度人用手抓饭吃，那他们吃火锅是怎么办呢！<br>　　我们中国人使用筷子，所以我们认为印度人用手抓饭是一个乖讹，乖讹点B是用手抓。B会被D点环境乖讹即特殊的食物火锅所否定。D是直接否定B的。</p>
<p>　　例</p>
<p>　　在公交车上，一个小伙子给一个老大爷让座。老大爷非常感动，非要和小伙子结拜。两人跪在地上，不求同年同月生，但求同年同月死。小伙子问大爷多少岁了，大爷说：我都九十了。<br>　　和一个比自己大得多的人结拜，就会被环境乖讹D同年同月死所否定。<br>　　狭义乖讹推导公式对讽刺有十分明显的效果，主人公一个微小的缺点，都会被乖讹推导成巨大的差异。<br>　　一个胖子刚从公交车上下来，售票员就会喊道：有空座了，有四个空座了。</p>
<p>　　例</p>
<p>　　牧师问丈夫：如果再过五分钟，地球就会毁灭，你要做什么？丈夫说：我要疯狂的做爱。妻子冷冷的问：那剩下四分钟呢！<br>　　早泄是一个乖讹，乖讹点B是时间太快。作者会安排一个D点是非常短的五分钟，主人公还给剩下了四分钟。<br>　　隐性的乖讹点<br>　　在一个简单的乖讹中，可以只有一个乖讹点。而在一个复杂的乖讹事件中，可以存在许多的乖讹点，它们通常死隐性的，不容易被发现，需要作者去发掘。</p>
<p>　　例</p>
<p>　　甲：我妻子骗了我，她说她昨天晚上和她妹妹在一起。<br>　　乙：你是怎么知道的？<br>　　甲：昨天晚上我和她妹妹在一起！<br>　　和小姨子偷情是一个乖讹是事件，在这个事件里，还存在一个乖讹点，主人公可以和小姨子呆在一起一个晚上，这是普通人无法做到的。利用这个乖讹点，设置了一个环境因素D妻子的谎话，妻子说和小姨子在一起，乖讹点B恰恰可以否定这个D点。</p>
<p>　　例</p>
<p>　　一个一丝不挂的美女钻进了出租车里，司机看了美女很久，美女生气的说：没见过美女呀！司机怒道：我看你他妈的从哪能把钱掏出来。<br>　　裸体美女是一个乖讹，这里还隐藏这一个乖讹点，没穿衣服就没有兜，没有地方装钱。这里设计一个需要钱的环境D，直接就把美女给否定了。</p>
<p>　　例</p>
<p>　　妻子对丈夫说：我要给你一个惊喜。丈夫问是什么？妻子说：我怀孕了。丈夫郁闷的说：我还不想要孩子。妻子笑着说：瞧你、瞧你！我说要给你一个惊喜，这只是一个惊。喜的是孩子不是你的，是隔壁老王的。<br>　　孩子不是自己的，这是一个乖讹，这里还隐藏一个乖讹点是，孩子不是自己的，就可以不用抚养了，然后有了不想要孩子的环境因素D，乖讹点B就可以否定环境因素D了。</p>
<p>　　在狭义乖讹推导理论中，乖讹点B是关键，一个段子的好坏，基本上取决于B的好坏。B点可以作用什么、攻击什么、否定什么，或者可以被什么攻击或否定，就可以把什么设定为环境因素D点。在这个公式中，关键是B点和D点的相互作用。</p>
<p>　　D点之所以可以区分A和A+B，主要的原因是B点和D点发生的巧妙作用。在前面的例子里，B点胡斐身材矮小，D点就设置为一个只有他能钻进去的洞。B点令狐冲没有内力，D点就设置为专门攻击内力的琴音。B点是可以和小姨子睡一宿，D点就是一个只有他可以揭穿的妻子的谎言。B点是孩子不是自己的，D点就设置为不想要小孩。A也可以和D发生作用，但A和D发生的作用只是没有象B一样和D发生巧妙作用的后果。在前面的例子中，A点众群侠没有钻过那个小洞，后果当然就是死。A点有内力的人遇到琴音，当然就是被攻击。A点普通人没有和小姨子睡一宿，当然是无法揭穿妻子的谎言。A点普通人孩子是自己的，当然无法解决不想要孩子的困难。</p>
<p>　　B的始终是一个段子能量点，D是根据B设计的。B是一个功能器，B可以做什么，就把D设置为什么。B如果是水，那么D就因该是火。B如果是一个苍蝇拍，D就应该是一只苍蝇。B如果是一只猫，D就应该是一只老鼠。在段子创作中，作者首先要在一个乖讹事件中寻找乖讹点，得到一个与众不同的乖讹点，通过乖讹点去设计D点，从而创作出一个完美的段子。<br>　　同样的B点，在不同的D点下，可以得到不同的结果。因为有些D点可以否定B，有些D点可以肯定B。我们以姚明为例，姚明是一个乖讹，乖讹点B是特别的高。如果是在D点篮球场上，姚明无疑是一个王者，所向披靡，无人能挡。但如果D点换成了战场，那情况就会大大的不同了，因为在战场上，姚明的目标太大，即使是枪法最差的士兵，也可以打中他。</p>
<p>　　一些看起来很差的B点，因为D点的作用，也会表现的很突出。例如胡斐身材矮小，在正常的环境下，他是很吃亏的，他不可能打败那些大侠。但在特殊的环境D点下，比如说那个小洞，胡斐就会表现出非凡的成就。令狐冲没有内力也是一个不好的乖讹点，在正常的环境里总是吃亏，但作者会安排一个只有他能过关的琴音环境。比如说一个盲人，正常环境下比常人差太多了，但如果在一个黑暗的环境里，他就会比正常人更加的适应。</p>
<p>　　乖讹的这种特点在文学中有着广泛的应用，一个非常好的乖讹点，在各种D点环境下风风火火，所向披靡。一旦遇到一个克制他的D点环境，立刻大败亏输，满盘皆负。而一个看起来很差的乖讹点，只要作者为他设计了好的D点，也可以如鱼得水，出人头地。这在文学创作中通常可以达到一个逆反的效果。</p>
<p>　　一些我们平时习以为常的乖讹点，在不同D点的作用下，就会发出不同的效果。如前面举得几个黄色笑话的例子，和小姨子偷情的乖讹，在妻子说谎的时候，竟然可以揭穿妻子的谎言。一个裸体美女，在遇到钱的问题时，竟然会被司机否定。孩子不是自己的，竟然可以解决不想抚养孩子的问题。大家注意没有，明星的签名字总是写的莫名其妙的，不像是正常的字。为什么会这样呢？</p>
<p>很早就看过一部香港影片，名字我已经忘记了。说的是洪金宝很崇拜刘德华，想要刘德华给他签名，刘德华于是就签了，结果洪金宝说刘德华已经加入了他们的组织，拿出一份证书，上面有刘德华刚才的签名。我也构制过类似的段子，说一个人找明星签名，签完之后才发现，是一份账单。</p>
<p>明星签名是一个乖讹点，当重新构制一个D点的时候，就又成了一个新的段子。一个脑筋急转弯说的是为什么一个仁慈的皇帝，却要诛人九族呢？答案是如果人都死了，就不会有人会伤心了。诛人九族的典故大家已经知道了，是一种非常残忍的手段，但它却可以解决有人伤心的问题。</p>
<p>我以前经常给故事类的杂志投稿，许多写手们混在一起，在论坛上大家经常会讨论一个问题。要不要从已知的文学作品中或新闻中提取乖讹进行创作，这样算不算是抄袭呢？今天这个问题已经没有讨论的必要了，作为故事或者说是段子的创作，本来就是利用已知乖讹进行再创作的的过程。</p>
<p>从新闻或文学作品中提取的乖讹B，只要我们重新设计一个D点和它发生巧妙的作用，这就形成了一个新的作品。这哪里是抄袭，这是重新创作。如果只是指着作者对生活中所能遇到的几个乖讹进行创作，那这个作者一生能够写出几个作品！利用已知文学作品或新闻的乖讹进行创作，本来就是段子手的两大阵地。</p>
<p>段子会分射雕段子、西游段子、三国段子，越是大家耳熟能详的乖讹，创作的段子越多。一个已知的乖讹，加上不同的D点，就会变成新的段子。甚至许多大的乖讹点也是可以分类的，如根据北京雾霾形成的段子，根据弹琴让邻居很闹心形成的段子，根据丈夫怕老婆形成的段子，根据鹦鹉学舌形成的段子，根据口吃形成的段子数不胜数。这些个大的乖讹点下面都有数不清的段子，每个人都可以根据自己想到的新的D点，和它们配合形成新的段子。</p>
<p>　　在狭义乖讹推导公式中，如果得到的是A+B，自然可以推出C+D。如果得到C+D和A，也可以推出A+B。如果得到的是B和D，也可以推出A和C。</p>
<p>　　在几十年前，苏联人就发明了发明机。发明机的原理很简单，只是把任何不同的两个物品组合在一起，他们就认为完成了一个发明。从狭义乖讹推导理论中，我们明白了，他们只是形成了一个乖讹。只有当乖讹点B和困难点D发生相互作用时，一个发明才真正成立。而且在发明中，以乖讹点B求取困难点D并不可取。发明真正的方法是，以困难点D去求取乖讹点B。发明就是为了解决我们所遇到的一个一个的困难。而在文学创作中则恰恰相反，作者努力的去寻找一个一个的乖讹，在长篇小说中，作者还要自己去创作乖讹。通过这些乖讹，得到乖讹点。再利用乖讹点构制与它发生巧妙作用的D点。这是才会形成一个段子。<br>　　乖讹推导还有一个变式，可以没有D点，B点直接作用于A点。B通常是A的倍数，作者把A设置成一个事件的关键点，或者是一个因果关系的起因，总之是很重要。B作用于A点，把A的功能扩大无数倍。</p>
<p>　　例</p>
<p>　　蜈蚣爸爸看见小蜈蚣正在哭，于是问道：你想要什么，孩子？小蜈蚣说：我想要买耐克鞋。<br>　　蜈蚣的脚是一个乖讹，他是正常脚的无数倍，A点是普通的脚，想买耐克鞋会让爸爸很头疼，也就是说，脚会让爸爸头疼。然后就是无数支脚，可以让爸爸疯掉。</p>
<p>　　例</p>
<p>　　医生将针头插入病人的体内，病人痛的一声惨叫。医生不耐烦的说：安静点好不好，我们是在做针灸，还有一百多针呢！<br>　　针灸可以看作是普通打针的乖讹，乖讹点B是普通打针的无数倍。A点是普通打针，A点可以给病人带来痛苦，B点是A点的超强版，病人应该昏过去了。<br>　　这种推导方法更适用于虚假相同差异关系对，下面我们开始讲解虚假相同差异关系对了。</p>
<h1 id="第三章虚假相同差异关系对"><a href="#第三章虚假相同差异关系对" class="headerlink" title="第三章虚假相同差异关系对"></a>第三章虚假相同差异关系对</h1><p>　　上文提到，B点其实是一个功能器，B点可以做什么，就把D点设置为什么。从而让D可以区分A和A+B。那么如果B点不是一个功能器，B其实做不了什么，只是和A的样子有些不同而已，那么又会怎样呢？<br>　　我们以哑语为例，哑语是一个乖讹，它相对的正常现象是正常的语言。但它和正常的语言已经不是很像了，它更像是一种舞蹈，于是哑语和正常的语言之间构成了一对真是相同差异关系对。哑语和舞蹈之间构成了一对虚假相同差异关系对。</p>
<p>　　狭义乖讹推导理论不止适用于文学，还适用于科学。而虚假相同差异关系对只适用于文学，甚至只适用于幽默。幽默本身就是一门研究误会的学问，如何让人产生误会？一定要存在看起来相似的两者，这两者就叫做虚假相同差异关系对。许多虚假相同差异关系对是天然的，如同音字、同音词、双关语，只要我们能够寻找出来就可以了。但更多的虚假相同差异关系对是需要我们去创造的。如何创造一个假对呢？自然是用乖讹的方法。</p>
<p>　　一个乖讹会和与它相对的正常现象构成一个真对，但乖讹通常不会和正常现象很像，而会像其他别的东西。乖讹就会和其他别的东西构成了一个假对。利用乖讹的这个特点，我们可以轻松地创造出许多新的假对。</p>
<p>　　例如郭德纲的段子：你行的，你和超人唯一的区别是你把裤衩穿里面了。</p>
<p>　　超人的服装是一个乖讹，尤其是裤子，看起来很像裤衩套在了裤子的外面。<br>　　赵本山的段子，宋丹丹：我年轻的时候，那是柳叶弯眉樱桃口，大人小孩都乐意瞅。就隔壁那吴老二，一见我就浑身发抖。赵本山：吴老二脑血栓，看谁都哆嗦。<br>　　脑血栓患者是一个乖讹，浑身总是不停的抖，看起来很像是一个人精神激动发抖。两者之间构成了一个假对。<br>　　长城汽车早期的商标是一个墙上有一个墙垛，不过画的已经不像墙垛了，而象是一个牙床上只有一颗牙。于是车迷们就把长城汽车戏称为一颗牙。<br>　　故事会里的一个故事，名字叫《你怎么学坏了》，说的是一个大学生毕业找工作，用人单位都要抽血体检。一个月下来，工作没找上，胳膊上却扎了许多的针孔。家里人发现了，以为他学坏了，开始吸毒了。<br>　　这种找工作体检是一个乖讹，会让胳膊上出现许多的针孔，看起来和吸毒的针孔很像，于是和吸毒构成了一个假对。<br>　　乖讹形成假对的手法，在动物笑话里有着普遍的应用。</p>
<p>　　例</p>
<p>　　赵本山的段子，老虎被蛇咬了，于是老虎去追蛇，追到了一条小河旁，蛇一下子钻进了水里。老虎在岸边等了半天，突然从水里爬上来一只王八，老虎上前一把把王八按住说：“好小子，你穿了马夹我就不认识你了。”<br>　　蛇穿了马夹是一个乖讹，看起来已经不像蛇了，而像是一只王八。穿了马夹的蛇和王八构成了一个假对。动物笑话的乖讹都是想象中的，事实上根本不存在。</p>
<p>　　例</p>
<p>　　母老鼠发现公老鼠偷偷的溜出了家门，于是在后面跟踪，走着走着，发现了一只刺猬。母老鼠上前按住了刺猬：“小样的，还说不是去约会，你打这么多的摩丝做什么。<br>　　打摩丝的老鼠是一个乖讹，看起来已经不像是一只老鼠了，而像是一只刺猬。打摩丝的老鼠和刺猬构成了一个假对。</p>
<p>　　例</p>
<p>　　饺子和馒头结婚了，洞房的时候，馒头发现饺子不见了，床上只躺着一个肉丸子。馒头于是要去找饺子，只听肉丸子说：‘死鬼，人家把衣服脱了，你就不认识人家了。”<br>　　脱了衣服的饺子和肉丸子形成了一个假对。</p>
<h2 id="语言类假对的构成"><a href="#语言类假对的构成" class="headerlink" title="语言类假对的构成"></a>语言类假对的构成</h2><p>　　语言只是对具体事物的描叙，语言是不存在乖讹推导的。语言形成的关系对没有真对，也就是说，语言含义形成的关系对通常都是假对，只有一些语法可以形成乖讹真对。<br>　　从天然的假对如多音字、同音词、双关语到曲解、歧义以及事物本身称呼的乖讹，都可以形成假对。在本文的一开头，我就介绍了假对的概念。假对是看起来相同，听起来相同，或其他部分相同，但本质上却是不同的两者之间。</p>
<p>　<strong>谐音一直是早期幽默创作的主流</strong>，</p>
<p>如马三立的段子《逗你玩》。妈妈让小孩在门口看着晾晒的衣服，一个贼走了过来，贼对小孩说：“我姓逗，叫逗你玩。”贼开始偷衣服，小孩对妈妈喊道：“他把褂子拿走了。”妈妈：“谁啊”。小孩：“逗你玩”。等妈妈出门看的时候，衣服已经被偷光了。妈妈问谁拿走的，小孩：都你玩。<br>　　这里，名字的逗你玩和调皮话逗你玩是一对同音的假对。它们的含义是不同的。</p>
<p>　　马三立的相声《开药铺》也是谐音的典范，两个外行人开药铺，不懂装懂。把中药银珠曲解为银子打的珠子，把中药砂仁曲解为三个人，把陈皮曲解为姓陈的皮匠。<br>　　现代相声如苗圃的《满腹经纶》也大量运用了谐音，取得了不俗的成就。</p>
<p>　　《非诚勿扰》的主持人孟非，你听他说话，几乎每一句话里都有谐音的包袱存在，运用的非常娴熟。谐音笑话如今已经不能成为幽默创作的主流了，乖讹推导才是幽默创作的主要手段。谐音胜在它的简单，不用去深思熟虑的布局，随口就来。一般会用在需要现场表演的场合，如主持人特别喜欢这种手法。在现场主持紧张的氛围下，很难去运用乖讹创作一个好的段子，而谐音的简洁手法符合了这种需要。</p>
<p>　　但对于一个有时间进行创作的作者来说，如果你总是用谐音，效果就不好了，别人会以为你不懂幽默。<br>　　曲解也是形成语言类假对的主要手段，效果通常会很好。</p>
<p>　　谐音只是语音相同，而字面上是不同的。曲解则不然，一个词或者一句话通常会有一个引申含义，还会有一个字面上的意思，这两个不同含义之间就构成了一个假对。这样形成的假对，由于字面上是完全相同的，所以效果很好，很轻松的就能够把读者给骗到。</p>
<p>　　例</p>
<p>　　郭德纲的一个段子，郭德纲想要吃鸡，于是去找一家做鸡的饭店。在一群发廊中间，找到了一家饭店。郭德纲问服务员：“你这有鸡吗？”服务员说：“嘘，我就是！”<br>　　鸡的引申含义是妓女，鸡的本意是一种家禽，鸡的两个不同含义之间就构成了一个假对。</p>
<p>　　例</p>
<p>　　阿拉伯酋长的儿子在伦敦读书，他给父亲发电报：同学们都坐地铁上学，只有我开着纯金的奔驰，我感到很不好意思。父亲回电报：已经给你汇去两个亿，赶快买一辆地铁，不要再给我丢人了。<br>　　这也是一个曲解，作者把儿子想坐地铁上学硬性曲解为同学都买的起地铁，而儿子买不起。</p>
<p>　　妻子把刚买的自行车撞到了树上，撞得稀巴烂。丈夫对妻子说：你若安好，便是晴天。妻子感动的流下了眼泪。丈夫接着说：你若安不好，嘿嘿，你可小心了。<br>　　你若安好，便是晴天。是一句关心的话。突然曲解为你要把自行车安好。两个不同含义构成了一个假对。</p>
<p>　　一个帅哥遇见了一个美女，帅哥对美女说：可以啪啪啪不。于是两个人进入了树林里。两人啪啪啪了半个小时，美女问帅哥:还啪啪啪不？帅哥说：不了，脸疼。<br>　　啪啪啪的引申含义是做爱，把它曲解为打脸的啪啪啪，两个不同含义构成了一个假对。</p>
<p>　　肢体语言形成的假对<br>　　肢体语言指的是手势，它通常会跟动作之间形成一个假对。</p>
<p>　　例</p>
<p>　　小蚊子哭着对妈妈说：爸爸死了。妈妈惊道：你们不是去看演唱会了吗，爸爸怎么会死呢？小蚊子说：观众们鼓掌，爸爸没躲开。<br>　　鼓掌是一个肢体语言，它和拍蚊子之间构成了一个假对。</p>
<p>　　例</p>
<p>　　两个贼准备翻墙去偷东西，甲先爬了上去，乙问甲：有没有保安。甲做了一个OK的手势。乙也爬了上去，刚上去，就被保安给抓住了。乙问甲：你不是说没有保安吗？甲说：三个保安。<br>　　OK是一个手势，表示好的的意思。它和树三个手指表示山的含义之间构成了一个假对。</p>
<p>　　鹦鹉和老鹰打架，被老鹰把毛全都拔光了，鹦鹉说道：不脱光膀子还真干不过你。<br>　　脱光膀子是一个肢体语言，表示要大干一场。而鹦鹉被老鹰拔光了毛和脱光膀子之间，成了一个假对。</p>
<h2 id="素材乖讹如何形成语言假对"><a href="#素材乖讹如何形成语言假对" class="headerlink" title="素材乖讹如何形成语言假对"></a>素材乖讹如何形成语言假对</h2><p>　　在上面的例子里，大家也看到了，如果得到一个好的语言假对，购置一个段子其实是一件很简单的事情。但问题的关键是，语言假对也不是凭空出现的，也需要作者去创造的。如何将一个幽默素材构成一个语言假对，是作者所面临的实实在在的问题。</p>
<p>　　最简单的方法当然是谐音了，汉字的同音词实在是太多了。你如果用的是搜狗拼音输入法，随便拼出一个词来，下面的选择框里就会有许多的同音词在等着你。利用谐音，几乎任何的词语都可以形成假对。但谐音假对的质量实在是不高，只有初学者或有时间限制的场合，比如主持人主持节目的时候才会用到。</p>
<p>　　高明一些的手法是曲解，一个词语或一句俗语通常会有一个引申含义，它的字面意思又会是另一个含义，这两个不同含义就构成了一个语言假对。这种假对的质量通常会很高。一个幽默素材如果是一个引申含义，就可以考虑和它字面的意思构成一个假对。如赵本山在小品《相亲》中，女主角说：我们还是等下辈子吧。赵本山说：完了完了，一竿子直到三零零零年去了。下辈子引申含义是不可能了，而作者将它曲解为真的要到下辈子，到三零零零年。</p>
<p>　　肢体语言形成的假对也是一个好方法，它会和一些动作形成假对，或者说一些动作会和它形成假对。这一点非常有用，如果你的素材乖讹是一个动作，你就可以考虑和一个肢体语言构成一个假对。反之，如果你的素材乖讹是一个肢体语言，你就可以考虑和一个动作构成一个假对。例如赵本山的小品《卖拐三》中，赵本山饰演一个脑血栓患者，两只手摆出了特殊的姿势。范伟说：这是什么呀，非常六加七呀！</p>
<p>　　素材乖讹转化成为什么关系对，如要是看这个素材乖讹本身有什么特点，所谓因才施用。如果素材乖讹适合形成一个真对，那就让它形成真对。如果适合形成乖讹假对那就形成乖讹假对。如果素材乖讹在语音方面很有特点，那就适合形成语言假对。</p>
<p>　　哈尔滨电台有位主持人叫莫红岩，莫是一个很有趣的姓，比如说莫吃，正常人的含义是不要吃。而对于莫姓的人来说，莫吃的意思是让姓莫的人来吃。于是我创作了一个段子。<br>　　台长买了一包耗子药，因为怕人误食了，于是在纸包上写了莫吃两个字。红岩看了脸上一红：台长就喜欢给人家开小灶。说着，把耗子药全吃了。</p>
<p>　　蔡明和潘长江的一个小品里，潘长江饰演的是一个喜欢跳舞的老年人，别人给他打电话，让他去参加一个节目，潘长江忙不迭的说：我去我去我去。蔡明在旁边冷冷的说：我去（拉长音）。拉长音的我去已经不是我去的意思，而是不去的意思，它和真正的我去之间构成了一个假对。</p>
<p>　　在小品《不差钱》里，小沈阳对毕姥爷说：我的中文名字叫小沈阳。毕姥爷问：你还有英文名字？小沈阳说：我的英文名字是小沈阳（学外国人的语调）。外国人语调的小沈阳是一个乖讹，但它并不是和真正的小沈阳构成假对，而是和英文名字构成假对。</p>
<h3 id="假对的推导方式"><a href="#假对的推导方式" class="headerlink" title="假对的推导方式"></a>假对的推导方式</h3><p>　　假对的最简单的推导方式当然形成误会，我们构制假对的目的也是为了让它形成误会。许多简单的笑话，其实就是一个误会。但误会作为幽默的基本元素，还是可以继续推导的。</p>
<h4 id="1误会在狭义乖讹推导理论中的应用"><a href="#1误会在狭义乖讹推导理论中的应用" class="headerlink" title="1误会在狭义乖讹推导理论中的应用"></a>1误会在狭义乖讹推导理论中的应用</h4><p>　　在狭义乖讹推导理论中我们知道，乖讹点B是一个功能器，B点决定了D点。B点可以做什么，就把D点设置为什么。而误会其实是一个最好的功能器，乖讹点B如果是样子和正常事物A不同，就可以引起D点的误会，从而让D点做出与众不同的表现。</p>
<p>　　例</p>
<p>　　老王上卫生间，进去了才发现自己进错了女卫生间。老王赶快往出走，正好碰上了一个要上卫生间的姑娘，姑娘看见了老王脸上一红，竟然扭头进了对面的男卫生间。<br>　　这个笑话里，老王进女卫生间是一个乖讹，乖讹点B看起来竟像是老王站在男卫生间的门口，从而引起了D点姑娘的误会，导致姑娘进了男卫生间。</p>
<p>　　例</p>
<p>　　一个浑身多处骨折的病人去看医生，医生问他是怎么弄得。病人说：我就用手扶着电线杆子去倒一倒鞋里的沙子，一个傻子就以为我触电了，用木棍疯狂的打我，结果就是这个样子了。<br>　　这个笑话里，用手扶着电线杆子不住的晃动，让人误以为是触电了，结果被D点一个傻子好炖打。</p>
<p>　　例</p>
<p>　　甲：你叫什么名字。<br>　　乙：我叫依洛、洛、洛、洛夫斯基。<br>　　甲：你是口吃吗？<br>　　乙：我不是，我爸爸是口吃，户籍登记处的那个工作人员简直是一个白痴。<br>　　这个笑话里，爸爸户籍登记时口吃，导致儿子竟然有了一个类似口吃的名字。<br>　　这个公式也是可以反推的，如果把主人公换成了D点，即那个上当的人，也可以产生许多好笑话的。</p>
<p>　　例</p>
<p>　　在地铁里，奶奶对孙女说：你看现在的人多开放啊，那两个人在地铁里就跳起舞来了。孙女说：奶奶，你看好了，那两个是聋哑人，他们在说哑语呢！<br>　　这个笑话里，两个人说哑语是一个乖讹，看起来好像是跳舞，引起了D点奶奶的误会。</p>
<h4 id="2假对在D点的作用下会有怎样的变化"><a href="#2假对在D点的作用下会有怎样的变化" class="headerlink" title="2假对在D点的作用下会有怎样的变化"></a>2假对在D点的作用下会有怎样的变化</h4><p>　　我们以前一直在讨论B点和D点的相互作用，那么一个假对在面对一个第三者D点的时候会有什么变化呢？我们可以把一个假对中的虚假的那个点设为假点A，而把假对中真实的那个点设为真点B。<br>　　当D点和假点A发生作用时得到的结果是E，当D点和真点B发生作用时得到的结果是F。</p>
<p>　　当看起来D点和假点A发生作用时，由于假点A和真点B是一个假对，事实上是D点在和真点B发生作用，这样得到的结果是，看起来D和A发生作用，实际上是D和B发生作用，看起来D和A发生作用得到的结果是E，而实际上却是D和B发生作用得到的结果是F。D和A发生作用得到的结果E在我们的脑海中是一个正常的脚本，而D和A发生作用得到的结果是F则是一个不正常的脚本，即产生了乖讹。说起来很绕嘴，还是举例说明吧。</p>
<p>　　例</p>
<p>　　两只青蛙却生出了一只癞蛤蟆，公青蛙勃然大怒，母青蛙安慰道：孩他爹，在嫁给你之前，我整过容。<br>　　在这个笑话里，整过容的癞蛤蟆和青蛙之间是一个假对。假点A是青蛙,真点B是整过容的癞蛤蟆。当遇到一个D点生孩子时，表面上是和假点A发生作用，也就是说青蛙和青蛙之间生孩子，但实际上是和真点B发生作用，也就是说青蛙和癞蛤蟆之间生孩子，得到的结果是生出了一只癞蛤蟆。表面上D和A发生作用，得到的结果却是生出了一只癞蛤蟆，这就是一个乖讹。<br>　　两个青蛙生出了一个癞蛤蟆，这是一个乖讹。答案是母青蛙其实是一只癞蛤蟆，也就是说是一只青蛙和一只癞蛤蟆生出了一只癞蛤蟆。</p>
<p>　　例</p>
<p>　　病人：医生，我感觉我有两个心脏在跳动。医生：啊，不好意思，我把手表落在你的肚子里了。<br>　　这个笑话里，手表和心脏是一个假对，假点A是心脏。真点B是手表。<br>　　乖讹是有两个心脏在跳动。手表在肚子里，病人误会它是心脏，于是有了两个心脏的乖讹。</p>
<p>　　例</p>
<p>　　孩子刚出世，喊了一声爷爷，爷爷阿的一声死了。喊了一声奶奶，奶奶阿的一声死了。喊了一声爸爸，爸爸阿的一声发现自己没死，叔叔阿的一声死了。<br>　　这个笑话里，假点A是表面上看起来是爸爸，真点B是其实不是爸爸。两者之间构成了一个假对。作者虚构了一个因果关系，孩子喊爷爷，爷爷就会死。喊奶奶，奶奶就会死。喊爸爸，爸爸没有死，这里形成了一个乖讹。因为正常现象爸爸因该死，爸爸没有死就是一个乖讹。答案是爸爸其实不是爸爸，叔叔才是爸爸。</p>
<p>　　例</p>
<p>　　小姨子把头枕在我的腿上，甜甜的睡着了，让我不忍心去叫醒她。这是妻子突然闯进房间里来了。我的脑袋突然翁了一下，不知道该怎么解释。妻子狠狠的瞪着我，突然说：你怎么还不送我妹妹上幼儿园。</p>
<p>　　这个笑话里，假点A是姐夫喜欢的小姨子，真点B是小姨子原来是上幼儿园的孩子。这种笑话是可以无限拓展的，比如说可以说小姨子偷偷的亲了我一下，被妻子发现了。小姨子和我在一起睡觉，被妻子发现了。</p>
<p>　　在D点和假对作用产生的乖讹其实都是虚假的乖讹，并不是真实存在的。如两只青蛙生出癞蛤蟆，其实并不是这样的，实际是一只青蛙和一只癞蛤蟆生出一只癞蛤蟆。如有两个心脏，其实是一只手表和一个心脏。而我们在狭义乖讹推导理论中推导出来的乖讹都是真实的乖讹。比如说由姚明身高的乖讹推导出的姚明在两米深的游泳池里淹不死的乖讹。比如说由煎饼形状的乖讹推出在一个门缝里，只有煎饼可以送进去。比如说在和小姨子偷情的笑话里，和小姨子呆在一起，却可以揭穿妻子的谎言。这些由狭义乖讹推导理论推导出来的乖讹都是真实有效的。而假对推出来的虚假乖讹却只是看起来是一个乖讹，其实是不存在的。假对可以推出虚假乖讹的方法在文学中有着广泛的应用，作者通常会用一个假对作为故事的底，利用它不断的推导出虚假的乖讹，最后再揭露答案。</p>
<p>　　如一个《开罚单》的故事，交警在给一辆路边违章停靠的车辆开罚单，一个人走了过去对交警说：能不能不开啊？交警没有理他，继续开罚单。这个人生气的说：有种你多开几张！交警真的就多开了几张。这人非常愤怒：有种你把车拖走。交警真的叫来了拖车把车给拖走了。这时这个人说道：这是谁的车这么倒霉，我还是骑我的自行车回家吧。<br>　　在这个笑话里，这个人不是车主，却装成是车主，形成了一个假对。作者利用这个假对不断地形成虚假乖讹，最后才揭露谜底。</p>
<h4 id="乖讹-解讹模式"><a href="#乖讹-解讹模式" class="headerlink" title="乖讹-解讹模式"></a>乖讹-解讹模式</h4><p>　　早期人们在研究乖讹论的时候，发现只有一个乖讹是不够的，单单的一个乖讹并不能引起多大的笑果。还需要在乖讹的后面加上一个为什么产生乖讹的原因，即解讹的模式。于是形成了一个笑话的标准模式，即乖讹-解讹模式。我们上面举得例子都属于乖讹-解讹模式，特点是先告诉读者一个乖讹，再告诉读者为什么会产生这个乖讹，即解讹。</p>
<p>　　真对形成的真实乖讹也可以构成乖讹-解讹模式，但真实乖讹的特点是B点和D点的巧妙作用，它的乖讹是真实存在的，即使不用乖讹-解讹模式，它的效果也会很好。而假对形成的虚假乖讹，如果不用乖讹-解讹的模式，而直接把假对的谜底揭露出来的话，那它形成的虚假乖讹几乎是毫无意义的，所以，乖讹-解讹模式更常用的是虚假乖讹。</p>
<h4 id="3真点B是假点A的否定式"><a href="#3真点B是假点A的否定式" class="headerlink" title="3真点B是假点A的否定式"></a>3真点B是假点A的否定式</h4><p>　　在前文中我们讨论过，乖讹推导理论有一个变式，即乖讹点B不用和环境点D发生作用，乖讹点B直接作用于正常点A。让正常点A成为一个事件的关键点，或一个因果关系中的起因，总之是很重要的部分。然后让B去否定A，从而否定了整个事件。<br>　　在假对中依然可以套用这个公式，让真点B成为假点A的否定式，而让假点A成为事件的关键点，或因果关系的起因部分，总之是很重要的部分。让真点B否定假点A从而否定了整个事件。</p>
<p>　　例</p>
<p>　　甲：打饭的队伍长吗?<br>　　乙：不长，很粗！<br>　　这个笑话里，打饭的人不按队伍排列，而是挤作一团，是一个乖讹事件。因为没有排列，所以不会很长，就和真正的不长构成了一个假对。假点A是虚假的不长，真点B是很粗，人都挤作一团。用假点A去回答问题，不长。用真点B去否定它，很粗。</p>
<p>　　例</p>
<p>　　小丽去逛街，看见一家店铺门口写着，进店就有礼赠送。小丽高兴地进去了，希望得到什么礼物。只见服务员冲她微微一笑：小女子这厢有礼了。<br>　　这个笑话里，小女子这厢有礼了是一句古代的俗语，在电视剧里经常听到。它和真正的有礼构成了一个语言假对，假点A是有礼赠送，真点B是小女子这厢有礼了。用假点A构成一个事件的关键点，即进店就有礼赠送。用真点B去否定它，原来是小女子这厢有礼了。</p>
<p>　　例</p>
<p>　　唐僧一觉醒来，发现孙悟空眼含热泪跪在自己的床前，唐僧惊道：悟空，你这是怎么了？孙悟空哭着说：师傅，求你以后不要在说梦话的时候念紧箍咒了。<br>　　这个笑话里，梦话和真正的话构成了一个假对，假点A是念紧箍咒，真点B是在说梦话。</p>
<p>　　例</p>
<p>　　一个大款出五百万让我和我的女朋友分手，我真的好紧张，我该怎么办呢？我是应该砍我的左手还是右手呢？<br>　　俗话说男人的手就是他最好的女朋友，于是手和女朋友构成了一个假对，假点A是女朋友，真点B是自己的手。利用假点A构成事件的关键点，即大款出五百万让我和我的女朋友分手。然后用真点B去否定，原来是要砍手。</p>
<p>　　例</p>
<p>　　一个水潭里养满了鳄鱼，一个富翁宣布，谁能跳下去游到对岸，我就把我的女儿嫁给他。话音未落，一个小伙子就跳了下去，他手足并用，很快的游到了对岸。富翁很激动，抓住小伙子的手说：我要把我的女儿嫁给你。小伙子甩开他的手冲着对岸说：刚才是谁他妈的把我推下去的？<br>　　这个笑话里，自己跳下去和被人推下去是一个假对。假点A是自己跳下去，真点B是被人推下去。让假点A成为事件的关键点，即谁跳下去就把女儿嫁给他。用真点B去否定它，即原来是被人推下去的。</p>
<p>　　例如在蔡明和潘长江的小品中，有人问潘长江去不去，潘长江说：我去、我去、我去。蔡明说：我去（拉长音）。我去（拉长音）和我去构成一个假对，假点A是我去，真点B是我去（拉长音）。只要假点A构成事件<br>的关键点，真点B就可以否定它。比如说有人问你晚上喝酒去不去，你说：我去(拉长音）。有人问你打麻将去不去，你说：我去（拉长音）。女朋友问你，晚上看电影去不去，你说：我去（拉长音），估计是一顿好打。</p>
<p>　　有一篇小小说，名字叫《永远的门》。说的是老李是剧院里的美工，是个老光棍，年纪很大了也没有老婆。他住在单位的宿舍里，住他隔壁的是一位离异的女士，和他年龄相仿。老李一直对这位女士有好感，但一直没有捅破这层窗户纸。后来老李得了癌症去世了，那位女士也搬走了。人们在为他收拾房间的时候，发现屋里有一扇屏风，把屏风撤掉以后，漏出了一扇门，这扇门是正对着女士的房间。人们这才恍然大悟，不禁发出了原来如此的感慨。有人去拉门，却发现没有门把手，原来这是一幅画在墙上的门。人们的心中都起了一种莫名的悲哀。<br>　　画在墙上的门和真正的门之间构成了一个假对，假点A是真正的门，真点B是画在墙上的门。利用假点A构成了故事的关键点，即他们偷情的工具。而利用真点B进行否定，把主人公的无奈的心里刻画的淋漓尽致。这个公式的关键是真点B对假点A的否定式，这种假对通常也是需要真点B对假点A的否定，即使是没有直接否定的关系对，也要把两者之间推导成否定式的关系对。</p>
<h4 id="4脚本转换"><a href="#4脚本转换" class="headerlink" title="4脚本转换"></a>4脚本转换</h4><p>　　脚本转换在本文开头已经介绍过，这里还要补充一些内容。<br>　　前面讲的几种假对的推导方式都是在一个脚本里进行的，而脚本转换则需要有两个脚本。上文提到的真点B对假点A的否定式，而在脚本转换中，需要的则是假对中假点A和真点B几乎是毫无关系的，没有任何关联的假对。作者需要对假点A和真点B分别构制一个脚本。对假点A构制的脚本叫做虚假脚本，对真点B构制的脚本叫做真实脚本。作者通常会把读者引入虚假脚本中，让读者深信不疑，然后突然地引出真实脚本。</p>
<p>　　例</p>
<p>　　一个脑筋急转弯<br>　　两个人掉进了陷井里，一个人摔死了，一个人还活着。摔死的人叫张三，活着的人叫什么？答案是：活着的人叫救命。<br>　　这个笑话里，叫什么是一个假对，假点A是叫什么名字，真点B是叫救命。作者利用假点A构制了一个虚假脚本让读者上当，读者会陷入到这个脚本当中，认为摔死的人叫张三，活着的人因该叫李四或者是王二麻子。最后作者推出真实脚本，其实不是什么名字，而是应该叫救命。</p>
<p>　　例</p>
<p>　　在小品《不差钱》中，毕姥爷问小沈阳：你叫什么名字。小沈阳：我的中文名字叫小沈阳。毕姥爷：你还有英文名字？小沈阳：我的英文名字叫小沈阳（学外国人腔调）。<br>　　这个笑话里，外国人腔调的小沈阳和英文名字之间构成了一个假对，假点A是真正的英文名字，真点B是学外国人腔调说出的名字。作者利用假点A构制了一个虚假脚本，让读者上当，读者会认为的英文名字是乔治、迈克、或汤姆之类的英文名。而作者却推出了真实脚本，原来是外国人腔调念出的小沈阳。<br>　　也可以先推出真实脚本，然后调侃式的推出虚假脚本。</p>
<p>　　例</p>
<p>　　一个女新手司机在等红灯，等了好几个红灯她也没有开过去。交警走过来问：这位女士，还没等到你喜欢的颜色吗？<br>　　真实脚本是等灯，而交警却故意引出另一个脚本，女司机在挑颜色，真实情况当然不是这个样子的，所以说这是一个调侃的虚假脚本。</p>
<p>　　例</p>
<p>　　外面工地施工，一块大石头被砰地一声爆破了。唐僧对孙悟空说：悟空，你妈给你生二胎了。<br>　　石头爆破和孙悟空出世形成一个假对，作者利用假点A石头爆破构制了一个孙悟空生二胎的虚假脚本。</p>
<p>　　例</p>
<p>　　现在这物价涨的，以前拿一块钱上超市，可以买两根肠、三瓶醋、四代盐。现在不行了，按摄像头了。<br>　　这是典型的脚本转换，作者先把读者引入一个以前物价便宜的脚本，然后突然引出了盗窃未遂的脚本。</p>
<h1 id="第四章乖讹的其他的推导方式"><a href="#第四章乖讹的其他的推导方式" class="headerlink" title="第四章乖讹的其他的推导方式"></a>第四章乖讹的其他的推导方式</h1><p>　　上面我们论述了素材乖讹的几种推导方式，可以把一个素材乖讹分解成为一个真实相同差异关系对，简称为真对。可以把一个素材乖讹分解成为一个虚假相同差异关系对，简称为假对。然后根据真对或假对的不同性质分别进行推导。然而许多的素材乖讹在笑话里是起着一些的辅助作用，并不会把它们直接分解为真对或假对。还有许多素材乖讹会作用于其他的事物，使其他的事物产生乖讹，形成关系对进行推导。许多的笑话并不止有一次的推导，素材乖讹会形成一个作品乖讹，利用作品乖讹再继续进行推导。对于各种复杂的情况，本章中将会一一的论述。</p>
<p>　　比如说雾霾是一个乖讹，根据北京雾霾构制的笑话是一筐一筐的，但通常不会把雾霾直接分解成为真对或假对，雾霾起着一个遮挡视线的作用，让人们会看不清楚。从而把许多正常情况下不会成为关系对的变成了关系对。</p>
<p>　　例</p>
<p>　　泼水节上，一个男子忽然大喊：他妈的谁用水泼我。众人忙向他解释，泼水是祝福的意思。男子说道：我知道，那他丫的也不能拿开水泼我呀。<br>　　泼水节是一个乖讹，但它在笑话里起的作用也是一个掩盖的作用，正常的情况不不可以向人泼水的，但在泼水节上却可以。真正形成的关系对是普通的水和开水。这个笑话如果把开水换成是洗脚水同样是成立的。例如，刚洗完脚，出门去倒洗脚水，突然想起今天是泼水节，直接把水泼到了对门大妈的脸上。</p>
<p>　　比如说口吃，口吃是一个乖讹，但通常不会把它分解为真对或假对。口吃会让说出的话变形，产生了一个语言的乖讹，这个语言的乖讹会和其他的语言构成一个语言假对，之后再对语言假对进行推导。口吃是一个系列，因为口吃会让说出的每一句话或每一个词语都产生变形，从而生出无数多的语言假对，所以根据口吃构制的段子是层出不穷的。</p>
<p>　　还有打岔的例子也是同样的道理，打岔是相声中经常用到的手法，听话者耳朵会很背，每句话都听错了，听错的话就会和正常的话形成假对，这样的假对会形成很多，所以打岔也是一个系列。<br>　　比如说姚明是一个乖讹，他的乖讹会作用于他身边的许多事物，形成许多新的乖讹。如姚明的衣服是一个乖讹，姚明的鞋子是一个乖讹，他的许多用品都会是乖讹。这些乖讹都可以单拿出来，形成真对或假对，进而形成一个笑话。</p>
<h2 id="乖讹的因果关系"><a href="#乖讹的因果关系" class="headerlink" title="乖讹的因果关系"></a>乖讹的因果关系</h2><p>　　许多的因果关系也会是一个乖讹，而且这种乖讹的用途会很广。乖讹的因果关系直接就可以形成一个真对，利用乖讹点B寻找一个D点，就可以形成一个好点子。</p>
<p>　　例</p>
<p>　　一只狼把一群羊给抓住了，准备要吃他们，领头的羊对狼说：只要你能够数出我们一共有多少只，我们就让你把我们吃掉。狼于是开始数羊，一只羊、两只羊、三只羊·······数着数着，狼就睡着了。<br>　　数羊能让人睡着，这是一个乖讹的因果关系。利用这个乖讹点，作者构制了一个它可以否定的狼的存在，从而购置了一个笑话。</p>
<p>　　例</p>
<p>　　一个外地人来到尚志，坐在了公交车里，正好赶上一个下雨天，他叹气说：我一来尚志就下雨，没有一会不下雨的。一个乘客笑道：那好啊，以后尚志天旱了就找你过来，立马就下雨了。<br>　　一来尚志就下雨是一个乖讹的因果关系，其实只是一个巧合。而那位乘客却假设它是一条永远成立的定律，把它作为了乖讹点B，构制了一个乖讹点B可以否定的困难D，即天旱的时候。</p>
<p>　　例</p>
<p>　　白雪公主耐不住寂寞，把匹诺曹的头夹在了两腿中间，说道：说实话、说谎话······<br>　　匹诺曹的鼻子说谎话的时候就会变长，这是一个乖讹的因果关系。把它作为一个乖讹点B，它的长短变化还可以实现一个功能，即作为一个jj。</p>
<p>　　<strong>乖讹的因果关系还有一个重要的功能，即成为一个放大器</strong>。什么是放大器呢？因果关系的起因是一个小小的变化，导致结果却是一个大大的变化。起因和结果之间有着巨大的差异，导致起因的小变化被结果给放大了，这就是一个放大器。比如说起因是数羊，却导致结果是睡着了。起因是说谎话，导致的结果是鼻子变长了。这有什么作用呢？在狭义乖讹推导理论中，乖讹点B是一个功能器，它能做什么，就会把什么设置为D点。所以需要乖讹点B尽量可以做一些伟大的事情，怎么才能办到呢，就需要这种放大器，B点也许只能做一些小事，通过放大器，却可以将它无限放大。在乖讹推导变式中，乖讹点B直接作用于正常点A，需要A成为事件的关键点，A如何成为关键点呢，也需要这种放大器，将A的小功能无限放大。在假对真点B是假点A的否定式中，要求假点A成为事件的关键点，也需要这种放大器才能够实现。说了放大器的这么多的作用，我们还是举例说明吧。</p>
<p>　　紧箍咒是一个乖讹的因果关系，说话就可以让一个人头疼，这种放大器把说话的功能给放大了。然后就有了一个唐僧说梦话念紧箍咒让孙悟空头疼的笑话。</p>
<p>　　比如说刚才数羊的笑话，在数羊会睡着的因果关系中，是利用睡着的乖讹点解决了狼要吃他们的困难。如果从放大器的角度考虑问题，从数羊上设置一个假对，也可以构制一个笑话。例如，地主让王二小放羊，对王二小说：如果丢了一只羊，就拔了他的皮。王二小很是担心，一边放羊，一边数羊，数着数着就睡着了，等他醒来的时候，羊都跑光了。</p>
<p>　　放大器的作用在计谋中有着很好的应用，计谋就是让人上当的，本来是骗的一件小事，通过放大器的作用，却可以扩大很多倍。计谋用的最多的书当然是三国演义，我举几个三国演义的例子。<br>　　望梅止渴<br>　　想到梅子就会让人流口水，这是一个乖讹的因果关系。作为放大器使用，只要曹操骗人说前面有梅林，就会得到流口水的效果。<br>　　草船借箭<br>　　如果晚上攻击敌人，敌人就会放出许多只箭。这是一个乖讹的因果关系。利用这种放大器的作用，只要装作攻击敌人，敌人就会放出很多只箭。</p>
<p>　　乖讹的因果关系，如果从结果入手，就会形成一个狭义乖讹推导公式。如果从起因入手，就会形成一个放大器。</p>
<h2 id="复杂的乖讹推导"><a href="#复杂的乖讹推导" class="headerlink" title="复杂的乖讹推导"></a>复杂的乖讹推导</h2><p>　　一个笑话通常不止一次的推导，基本上会有两次。而在一个复杂的故事中，甚至存在着多次的推导。</p>
<p>　　例如泼水节的笑话里，男人让开水给泼了，这已经是一个推导成功的作品乖讹。但还是会对它进行二次的推导，让男人被开水泼了的大喊和不懂泼水节规矩的大喊构成一个假对，然后进行一个脚本转换。</p>
<p>　　前面举过的姚明的笑话里，利用姚明的身高的素材乖讹推导出的姚明在两米深的游泳池里不会被淹死的作品乖讹。这个作品乖讹还会对它进行推导，让它和不会游泳之间形成一个假对，假点A是不会游泳，真点B是可以在水里行走不会淹死。假点A成为事件的关键点，让人认为你不会游泳当什么救生员，不是无理取闹吗，然后用真点B进行否定。</p>
<p>　　例</p>
<p>　　老张的老婆非常关心老张，每天总要打电话问老张中午想要吃什么。每天总是这样，搞得老张有些烦了。一天，老婆又打电话问老张吃什么，老张没好气的说：吃你。中午，老张回到家，发现老婆并没有做饭而是在院子里不停地跑步，跑得满头大汗的，老张奇怪的问：你在做什么？老婆说：我在给你热菜呢！<br>　　这个笑话里，首先是有一个吃你的语言假对，假点A是要吃人，真点B是一句比喻的气话。把真点B曲解成为假点A时，真的吃人变成了一个乖讹。然后又对这个吃人的乖讹进行推导，推出了热菜的乖讹。</p>
<p>　　在故事的创作中，乖讹的推导更加的复杂，通常作者最初的点子叫做故事核，通过故事核继续推导出新的情节。一个好故事不只需要点子好，更需要写得好，即故事核的推导情节也很精彩。<strong>我将会在我的下一篇文章《点子与布局》中，详细论述这些复杂乖讹推导问题，敬请大家期待</strong>。</p>
<h1 id="第五章如何得到素材乖讹"><a href="#第五章如何得到素材乖讹" class="headerlink" title="第五章如何得到素材乖讹"></a>第五章如何得到素材乖讹</h1><p>　　从前文的论述中大家可以知道，只要有了一个好的素材乖讹，要想形成一个段子，只不过是一些公式而已。也不是我自夸，像我这种级别的段子手，如果得到一个好的素材乖讹，形成一个段子，那是手到拈来的事情。段子手拼到后来，拼的也不过是素材乖讹的好坏，有了好的素材乖讹，自然可以形成好的段子。那么该如何得到好的素材乖讹呢？下面我们来讨论一下这个问题。</p>
<h2 id="1生活中的乖讹"><a href="#1生活中的乖讹" class="headerlink" title="1生活中的乖讹"></a>1生活中的乖讹</h2><p>　　如果你不喜欢写作，也不喜欢文学，也不喜欢段子创作，你只是想成为一个生活中风趣幽默的人。那好了，我只要告诉你一个小方法，你就可以成为一个幽默的人了。</p>
<p>　　如果你从哪里得来的一个小段子，想讲给别人听，逗大家哈哈大笑，这基本上是不会成功的。因为我们根本没有大兵讲笑话的水准，而且这根本是没有什么意义的。一个真正好笑的笑话，是需要你和你的小伙伴们处在一个团体中，这时自然的发生了一个乖讹事件或出现了一个乖讹的事物，你把这个自然出现的素材乖讹推导成为一个作品乖讹，这才能引起大家的哄堂大笑。生活中幽默的人，首先是一个善于观察的人，可以观察到这种乖讹的出现，然后迅速的把它转化为作品乖讹。生活中的乖讹比比皆是，只要你细心观察，总会有所收获。</p>
<p>　　在这里我要提倡一种娱乐精神，许多的乖讹是在某一个人的身上出现的，可能是他的一个缺陷，或者是他的一个失误，作者就会利用这种素材乖讹，推导出作品乖讹逗大家开心。但有些人真的很小气，发现笑话的主角是自己，立刻就翻脸了。这就不好了吗，应该有一点娱乐的精神，作者利用他的缺陷构制段子，固然有一些讽刺的成分在里面，但更多的目的是娱乐大家。</p>
<p>我的名字叫张国强，在小学二年级的时候，就有同学发现我的名字和八仙之一的张果老很像，于是就给我起了一个外号叫张果老。这让我很郁闷，又没有什么办法。终于熬到了初中，我想这个外号可以消失了吧，没想到又有几个我小学同学和我到了一个班里，他们把我的外号也带来了。到了高中依然是这种情况，我的外号依然在沿用着。到了高中毕业，我的外号终于消失了，我还没有高兴几天，一个新的团队又给我起了一些新的外号，而且比原来更狗血。随着年纪的增大，我不再介意别人给我起的外号，没有外号不发家吗！其实这就是一种娱乐精神，你作为一个乖讹的存在，别人利用你创作了一个段子，其实是你和作者共同创作了这个段子，娱乐了大家，没有什么好介意的。</p>
<h2 id="2动物笑话"><a href="#2动物笑话" class="headerlink" title="2动物笑话"></a>2动物笑话</h2><p>　　如果把动物用拟人的方法去写，那么动物就变成了一个乖讹的人。比如说蜈蚣，蜈蚣如果用拟人的手法就变成了一个蜈蚣人，蜈蚣人和正常人的乖讹点是有无数条腿。不只是动物，植物、物体、物品都可以用拟人的手法去写，它们会变成各种乖讹的人。这里最值得推荐的是马季的相声《五官争功》，作者把五官利用拟人的手法，做成眼人、耳人、口人、鼻人。再利用四种乖讹，变化出了大量的段子，整个作品包袱不断，实在是上乘之作。</p>
<h2 id="3文学笑话"><a href="#3文学笑话" class="headerlink" title="3文学笑话"></a>3文学笑话</h2><p>　　利用文学作品中的乖讹构制笑话，也是笑话的一大门类。其中用的最广泛的是《西游记》，根据西游记购置的笑话也是层出不穷。比如说紧箍咒是一个乖讹，乖讹点是说一句话就可以让人头疼。金箍棒是一个乖讹，乖讹点是可以变大变小的棍子。唐僧肉是一个乖讹，一种吃了可以长生不老的人肉。利用武侠故事乖讹构制的笑话也有很多，比如说屠龙刀是一个乖讹，乖讹点是削铁如泥。点穴是一个乖讹，乖讹点是可以让人不动。轻功是一个乖讹，乖讹点是人可以在空中飞。</p>
<p>　　有人说周星驰的每一部古代题材的影片都是成功的，而现代题材的影片，成功的一半都没有。这是因为古代的人物或事件相对于现代人来说几乎都是乖讹，乖讹点会很多，能构成的段子也就多。如古代人的头发是乖讹，古代人的衣服是乖讹，古代人的交通工具是乖讹。而周星驰的喜剧电影就是靠段子取胜的，现代题材的影片里乖讹很少，形成的段子也就少，所以不会成功。当你看惯了现代电视剧的一些狗血元素，如大款、黑社会、同性恋、艾滋病、白血病。你会奇怪为什么用烂了还要用，不要怪那些编剧了，现代社会就这么些乖讹元素，不用又能怎么办。</p>
<h2 id="4新闻笑话"><a href="#4新闻笑话" class="headerlink" title="4新闻笑话"></a>4新闻笑话</h2><p>　　新闻是现代笑话创作的第一素材乖讹库，段子手需要它，几乎每一个新闻出来以后，就会有大量的段子手聚集，产生出大量的段子。几年之前，哈尔滨电台有一档栏目叫《天天资讯》，主持人以另类的方式播报新闻，真的是很新颖，很奇特。每个新闻其实就是一个素材乖讹，主持人可以用它们推导出段子，但这还是有些难为主持人了。不过电台是一个很好的互动节目，主持人可以和听众互动。主持人刚说一个新闻，听众中的段子手早就构制成段子发给主持人了。过了几年，这种栏目已经是很普遍了。什么脱口秀、搞笑栏目都会用到新闻。这已经是搞笑类栏目的重要方式。</p>
<h2 id="5黄色笑话"><a href="#5黄色笑话" class="headerlink" title="5黄色笑话"></a>5黄色笑话</h2><p>　　弗洛伊德从生理学的角度提出了一种幽默理论，叫做宽慰轮。他说普通的笑话只能让人浅浅的笑，只有和性有关的笑话才可以让人开怀大笑。有一份调查说，百分之六十三的笑话是黄色笑话，也不知道他的数据是怎么得出来的。但可以肯定的是，黄色笑话至少占据笑话的半壁江山。和性有关的那些事，只需简单地推导，就可以形成一个好的笑话。许多黄色笑话电台是不让讲的，但真的不需要特别黄的，只需要和性有关的一些小事，就可以弄出好的笑话。有时候也会让作者很为难，为什么总是要往这方面靠拢呢，但真的没有办法，这是制造幽默的最好手段。</p>
<h2 id="6残疾人笑话"><a href="#6残疾人笑话" class="headerlink" title="6残疾人笑话"></a>6残疾人笑话</h2><p>　　亚里士多德提出了一种幽默理论叫优越论，说的是笑话里总会有残疾人或傻子的存在，人们是因为看到他们做的傻事，产生了自己的优越感，所以会笑。其实残疾人也是一种很重要的素材乖讹门类，任何残疾都是一种乖讹。不过幽默也是有底线的，诸如盲人或没有手脚的严重残疾没有人会拿他们开玩笑的。我们使用的一些残疾乖讹，通常是一些小残疾，开开玩笑无伤大雅的。</p>
<h2 id="7医生笑话"><a href="#7医生笑话" class="headerlink" title="7医生笑话"></a>7医生笑话</h2><p>　　这也是一个很重要的素材乖讹门类，得了各种病的病人，总是会和正常人不一样的，是一种乖讹。医生手术，会把病人的这里或那里切掉，这也是不正常的现象。<br>　　素材乖讹还会分很多的门类，这里就不一一的介绍了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　读到这里，我相信许多读者已将本文粗略的看了一遍。但还是感到懵懵懂懂，不知所以然，我也只能告诉大家，多读几遍。</p>
<p><strong>我研究这套理论用了十年时间，如果你瞬间就理解它掌握它，那我只能说你是神而不是人了。</strong></p>
<h1 id="本文总结-简化版写笑话方法"><a href="#本文总结-简化版写笑话方法" class="headerlink" title="本文总结-简化版写笑话方法"></a>本文总结-简化版写笑话方法</h1><p>　　我在这里弄了一个简化版出来，你可以试着从简化版入手，一点一点的掌握乖讹推导的方法。</p>
<ol>
<li>其实很简单，我们首先要得到一个幽默素材，这个素材必须是一个乖讹，叫做素材乖讹。</li>
<li>然后看素材乖讹与它相对的正常现象之间的差异，这个差异就是乖讹点B。</li>
<li>有了乖讹点，然后看乖讹点可以做什么，也就是说乖讹点是一个功能器。乖讹点可以做什么，可以否定什么，或者可以被什么否定，我们就把什么设定为环境点D。D点和B点共同构成了一个点子。</li>
<li>如果乖讹点B并不能做什么，它只是和正常现象之间样子有些不同，那么它象什么，它就和什么构成一个虚假相同差异关系对，简称假对。然后我们再对假对进行推导。</li>
</ol>
<p>　　你可以从简化版入手，试着找到一些乖讹，对它进行推导，渐渐地熟悉了以后，对你的智商是一个很大的提高。我在前面已经说过了，我的乖讹推导理论是对人类创造力的公式化处理。以前只有一些天才能够想出来的点子，普通人只要学会了我的推导方法，也可以轻松的推导出好的点子。</p>
<p>　　我的终极梦想还是希望用我的理论，让人工智能技术有一个飞跃，让人类可以早日研究出像人一样聪明的的机器人。如果你真正的懂了我的这套理论，我希望你加入进来，这是当今科学最有前途的一个突破点。</p>
<h1 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h1><p>作者张国强 新浪微博@张扬大<br>　　<br><a href="https://zhuanlan.zhihu.com/p/44548925?utm_medium=social&amp;utm_oi=28712972058624&amp;utm_psn=1608463909458997248&amp;utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44548925?utm_medium=social&amp;utm_oi=28712972058624&amp;utm_psn=1608463909458997248&amp;utm_source=wechat_session</a></p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/mac_notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mac_notes/" itemprop="url">mac stuff</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-07T03:02:22+00:00">
                05-07-2022
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Misc/" itemprop="url" rel="index">
                    <span itemprop="name">Misc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <p>这是一份 mac 折腾配置以及各种改造的精华笔记, 可以帮你从头到尾打造一个极为顺手的 mac. </p>
<p>在Windows端配合<a href="https://github.com/no5ix/sux" target="_blank" rel="noopener"><i class="fa fa-fw fa-github fa-2x"></i>sux</a> 可以统一 win &amp; mac 的使用体验.</p>
<p><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </p></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/actor_vs_csp_mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/actor_vs_csp_mode/" itemprop="url">Actor模型 vs. CSP模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-21T02:53:55+00:00">
                07-21-2021
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Misc/" itemprop="url" rel="index">
                    <span itemprop="name">Misc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <p>Akka/Erlang 的 actor 模型与 Go 语言的协程 Goroutine 与通道 Channel 代表的 CSP(Communicating Sequential Processes) 模型有什么区别呢？</p>
<p>首先这两者都是并发模型的解决方案，我们看看 Actor 和 Channel 这两个方案的不同：</p>
<h1 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h1><p>在 Actor 模型中，主角是 Actor，类似一种 worker，Actor 彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：</p>
<p><img src="/img/actor_vs_csp_mode/actors_mode.png" alt></p>
<p>Actor 模型描述了一组为了避免并发编程的常见问题的公理:</p>
<ol>
<li>所有 Actor 状态是 Actor 本地的，外部无法访问。  </li>
<li>Actor 必须只有通过消息传递进行通信。　　  </li>
<li>一个 Actor 可以响应消息: 推出新 Actor, 改变其内部状态, 或将消息发送到一个或多个其他参与者。  </li>
<li>Actor 可能会堵塞自己, 但 Actor 不应该堵塞它运行的线程。</li>
</ol>
<p>更多可见 <a href="http://www.jdon.com/actors.html" target="_blank" rel="noopener">Actor 模型专题</a></p>
<p><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </p></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/self_cultivation_etcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/self_cultivation_etcd/" itemprop="url">服务器开发自我修养专栏-etcd与raft要点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-17T19:08:06+00:00">
                05-17-2021
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Self-cultivation/" itemprop="url" rel="index">
                    <span itemprop="name">Self-cultivation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><ul>
<li>etcd 参考 <a href="https://wingsxdu.com/post/database/etcd/#gsc.tab=0" target="_blank" rel="noopener">https://wingsxdu.com/post/database/etcd/#gsc.tab=0</a></li>
<li>raft 参考 <a href="https://www.jianshu.com/p/5aed73b288f7" target="_blank" rel="noopener">https://www.jianshu.com/p/5aed73b288f7</a></li>
<li><p>重点参考 <a href="https://segmentfault.com/a/1190000022248118" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022248118</a></p>
</li>
<li><p>etcd 是一个 Go 语言编写的分布式、高可用的<strong>强一致性</strong>键值存储系统，用于提供可靠的分布式键值(key-value)存储、配置共享和服务发现等功能。 etcd可以用于存储关键数据和实现分布式调度，它在现代化的集群运行中能够起到关键性的作用。</p>
</li>
<li><p>Raft用于保证分布式数据的一致性。<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画演示Raft</a></p>
</li>
</ul>
<h2 id="Raft选主过程"><a href="#Raft选主过程" class="headerlink" title="Raft选主过程"></a>Raft选主过程</h2><video width="100%" controls="controls"><br><source src="/img/noodle_plan/etcd/leader_election.webm" type="video/mp4"><br></video>

<p><a href="http://thesecretlivesofdata.com/raft/#election" target="_blank" rel="noopener">动画演示Raft选主</a><br>前提知识:  </p>
<ul>
<li>Election timeout选举周期: The election timeout is the amount of time a follower waits until becoming a candidate.</li>
<li>heartbeat timeout心跳时间间隔</li>
</ul>
<p><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </p></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/python_reload_func_closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/python_reload_func_closure/" itemprop="url">python的reload对于func_closure的处理踩坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-08T17:55:26+00:00">
                05-08-2021
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Misc/" itemprop="url" rel="index">
                    <span itemprop="name">Misc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <p>带着问题学习动力是较强的, 直接上例子</p>
<p><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </p></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/self_cultivation_redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/self_cultivation_redis/" itemprop="url">服务器开发自我修养专栏-Redis实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-20T19:08:06+00:00">
                04-20-2021
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Self-cultivation/" itemprop="url" rel="index">
                    <span itemprop="name">Self-cultivation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="redis-数据结构有哪些？分别怎么实现的？"><a href="#redis-数据结构有哪些？分别怎么实现的？" class="headerlink" title="redis 数据结构有哪些？分别怎么实现的？"></a>redis 数据结构有哪些？分别怎么实现的？</h2><ul>
<li>String: <ul>
<li>全是整数的时候用<code>整数编码int</code></li>
<li>当有字符串的时候用<code>简单动态字符串sds</code>编码</li>
</ul>
</li>
<li>HashTable: <ul>
<li>元素比较少或者元素比较短的时候用<code>压缩表ziplist</code>(key1|val1|key2|val2|…这样存储), </li>
<li>其他时候就用<code>字典ht</code></li>
</ul>
</li>
<li>Set: <ul>
<li>元素全是整数的时候用<code>整数集合</code>编码(一种特殊的编码, 会使用各种规则来利用位空间, 来节省内存), </li>
<li>其他时候用<code>字典ht</code>编码(键为Set的元素, 值都为Null)</li>
</ul>
</li>
<li>List: <ul>
<li>元素比较少或者元素比较短的时候用<code>压缩表ziplist</code>,</li>
<li>其他时候就用<code>双端列表LinkedList</code>编码</li>
</ul>
</li>
<li>ZSet: <ul>
<li>参考 <a href="http://redisbook.com/preview/object/sorted_set.html" target="_blank" rel="noopener">http://redisbook.com/preview/object/sorted_set.html</a></li>
<li>参考 <a href="https://redisbook.readthedocs.io/en/latest/datatype/sorted_set.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/datatype/sorted_set.html</a></li>
<li>元素比较少或者元素比较短的时候用<code>压缩表ziplist</code>(member1|score1|member2|score2|…, 按照score从小到大排列), </li>
<li>其他时候就用<code>跳跃表SkipList编码</code>, 这个编码里包含一个字典结构和一个跳表结构, 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存:  <ul>
<li>字典用于快速查找, 如<code>ZScore</code>查询member成员的 score 值, 或者快速确定是否有某个member</li>
<li>跳表用于<code>zrank</code>/<code>zrange</code>等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="zset各种问题"><a href="#zset各种问题" class="headerlink" title="zset各种问题"></a>zset各种问题</h2><h3 id="为什么zset用跳表不用红黑树"><a href="#为什么zset用跳表不用红黑树" class="headerlink" title="为什么zset用跳表不用红黑树"></a>为什么zset用跳表不用红黑树</h3><p>现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p>
<p>There are a few reasons:</p>
<ul>
<li>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</li>
<li>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</li>
<li>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</li>
</ul>
<p>可参考:  本博客文章<a href="/algo_newbie/#跳表">跳表</a><br>总结:<br><!-- * 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。 --></p>
<ul>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ul>
<h3 id="zset是怎么支持查询排名的"><a href="#zset是怎么支持查询排名的" class="headerlink" title="zset是怎么支持查询排名的"></a>zset是怎么支持查询排名的</h3><p><a href="/algo_newbie/#跳表怎么支持查询排名的">跳表怎么支持查询排名的</a></p>
<h3 id="延时队列用redis怎么做"><a href="#延时队列用redis怎么做" class="headerlink" title="延时队列用redis怎么做"></a>延时队列用redis怎么做</h3><p>用zset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者轮询zset用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
<h3 id="ZSET做排行榜时要实现分数相同时按时间顺序排序怎么实现"><a href="#ZSET做排行榜时要实现分数相同时按时间顺序排序怎么实现" class="headerlink" title="ZSET做排行榜时要实现分数相同时按时间顺序排序怎么实现"></a>ZSET做排行榜时要实现分数相同时按时间顺序排序怎么实现</h3><p>说了一个将 score 拆成高 32 位和低 32 位，高 32 位存分数，低 32 位存时间的方法。</p>
<h2 id="哈希表渐进式rehash"><a href="#哈希表渐进式rehash" class="headerlink" title="哈希表渐进式rehash"></a>哈希表渐进式rehash</h2><ul>
<li><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：  </p>
<ul>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li>
<li><p>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</p>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
</li>
</ul>
</li>
<li>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</li>
</ul>
<p>以下是哈希表渐进式 rehash 的详细步骤：  </p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 rehashidx 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h2 id="redis-持久化有哪几种方式，怎么选？"><a href="#redis-持久化有哪几种方式，怎么选？" class="headerlink" title="redis 持久化有哪几种方式，怎么选？"></a>redis 持久化有哪几种方式，怎么选？</h2><ul>
<li>混合持久化<ul>
<li>原因: 重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。如果使用 AOF 日志重放，性能则相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动的时候需要花费很长的时间。</li>
<li>原理: 混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将aof_rewrite_buf重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。</li>
<li>简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据，</li>
</ul>
</li>
<li>rdb<ul>
<li>优势: <ul>
<li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>
<li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
</li>
<li>劣势:<ul>
<li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>
</ul>
</li>
</ul>
</li>
<li>aof<ul>
<li>优势: <ul>
<li>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个<strong>后台刷盘线程</strong>执行一次fsync操作(这种一秒刷盘一次的策略, 可能会造成<strong>追加阻塞</strong>: 当硬盘资源繁忙时，即主线程发现距离上次fsync时间超过2秒, 为了数据安全性, 主线程会阻塞直到后台刷盘线程执行fsync操作完成)，保证最多丢失1秒钟的数据。所以这也是redis重启优先加载aof的理由</li>
<li>AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>
<li>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li>
<li>AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</li>
</ul>
</li>
<li>劣势:<ul>
<li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li>
<li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="bgsave流程说一下"><a href="#bgsave流程说一下" class="headerlink" title="bgsave流程说一下"></a>bgsave流程说一下</h3><p><img src="/img/noodle_plan/redis/bgsave.png" alt></p>
<p>子进程创建RDB文件, 根据父进程内存生成临时快照文件, 完成后对原有RDB文件进行<a href="#如何做rdb和aof的原子替换的">原子替换</a>. 然后子进程发送信号给父进程表示完成</p>
<h3 id="aof流程说一下以及aof追加阻塞是啥"><a href="#aof流程说一下以及aof追加阻塞是啥" class="headerlink" title="aof流程说一下以及aof追加阻塞是啥"></a>aof流程说一下以及aof追加阻塞是啥</h3><p><img src="/img/noodle_plan/redis/aof.png" alt></p>
<p>追加阻塞: </p>
<p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台刷盘线程执行一次fsync操作(这种一秒刷盘一次的策略, 可能会造成追加阻塞: 当硬盘资源繁忙时，即主线程发现距离上次fsync时间超过2秒, 为了数据安全性, 主线程会阻塞直到后台刷盘线程执行fsync操作完成)，保证最多丢失1秒钟的数据。</p>
<h3 id="AOF重写的实现"><a href="#AOF重写的实现" class="headerlink" title="AOF重写的实现"></a>AOF重写的实现</h3><ul>
<li><strong>所谓的“重写”其实是一个有歧义的词语, AOF重写并不需要对原有AOF文件进行任何的读取，写入，分析等操作，这个功能是通过读取服务器当前的数据库状态来实现的。</strong></li>
<li>如当前列表键list在数据库中的值就为<code>[&quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</code>。要使用尽量少的命令来记录list键的状态，最简单的方式不是去读取和分析现有AOF文件的内容，，而是直接读取list键在数据库中的当前值，然后用一条<code>RPUSH list &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot;</code>代替前面的6条命令</li>
</ul>
<p>AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：  </p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求。</li>
<li>子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。</li>
</ul>
<p>不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。为了解决这个问题， <strong>Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个重写缓存中</strong>, 换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：  </p>
<ol>
<li>处理命令请求。</li>
<li>将写命令追加到现有的 AOF 文件中。</li>
<li>将写命令追加到 AOF 重写缓存中。</li>
</ol>
<p>当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：  </p>
<ol>
<li>将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。</li>
<li>对新的 AOF 文件进行改名<code>rename</code>，覆盖原有的 AOF 文件。这就是aof的<a href="#如何做rdb和aof的原子替换的">原子替换</a>.</li>
</ol>
<p>在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。以上就是 AOF 后台重写， 也即是 BGREWRITEAOF 命令的工作原理。</p>
<h3 id="如何做rdb和aof的原子替换的"><a href="#如何做rdb和aof的原子替换的" class="headerlink" title="如何做rdb和aof的原子替换的"></a>如何做rdb和aof的原子替换的</h3><p>比如想要将temp文件原子替换origin文件, 则直接<code>rename</code> tmp文件到origin文件即可实现.<br><code>rename</code>通过来说, 直接修改 file system metadata, 如inode信息. <strong>在posix标准里, <code>rename</code>实现是原子的</strong>, 即:  </p>
<ul>
<li><code>rename</code>成功, 原文件名 指向 temp 文件; 原文件内容被删除.</li>
<li><code>rename</code>失败, 原文件名 仍指向原来的文件内容.</li>
</ul>
<h2 id="redis-主从同步是怎样的过程？"><a href="#redis-主从同步是怎样的过程？" class="headerlink" title="redis 主从同步是怎样的过程？"></a>redis 主从同步是怎样的过程？</h2><ol>
<li>从redis发出sync要求</li>
<li>主redis开始bgsave(并且一边开启指令buffer来存储bgsave过程中的写指令们记为<code>cmd</code>)</li>
<li>主redis把bgsave生成的rdb发给从redis</li>
<li>把<code>cmd</code>发送给从redis</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li>
</ol>
<p>总结:<br>主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<h2 id="redis-key-的过期策略"><a href="#redis-key-的过期策略" class="headerlink" title="redis key 的过期策略"></a>redis key 的过期策略</h2><p>Redis键的过期策略，是有定期删除+惰性删除两种。</p>
<ul>
<li>定期好理解，默认100ms就 随机 抽一些设置了过期时间的key，去检查是否过期，过期了就删了。</li>
<li>惰性删除，查询时再判断是否过期，过期就删除键不返回值。</li>
</ul>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>当新增数据发现内存达到限制时，Redis触发内存淘汰机制。</p>
<ul>
<li>lru</li>
<li>lfu(least frequency used, redis 4新增)</li>
<li>random</li>
<li>ttl</li>
</ul>
<h3 id="redis的LRU算法说一下"><a href="#redis的LRU算法说一下" class="headerlink" title="redis的LRU算法说一下"></a>redis的LRU算法说一下</h3><ul>
<li><strong>普通的LRU算法</strong>:<br>  <strong>一般是用哈希表+双向链表来实现的</strong>:<br>  <img src="/img/noodle_plan/redis/lru_cache_algo.jpg" alt><br>  基于 HashMap 和 双向链表实现 LRU 的整体的设计思路是，可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点. 其核心操作的步骤是:  <ul>
<li>save(key, value):<br>首先在 HashMap 找到 Key 对应的节点，如果节点存在，更新节点的值，并把这个节点移动队头。如果不存在，需要构造新的节点，并且尝试把节点塞到队头，如果LRU空间不足，则通过 tail 淘汰掉队尾的节点，同时在 HashMap 中移除 Key。</li>
<li>get(key):<br>通过 HashMap 找到 LRU 链表节点，因为根据LRU 原理，这个节点是最新访问的，所以要把节点插入到队头，然后返回缓存的值。</li>
</ul>
</li>
<li><strong>Redis的LRU实现</strong>:<ul>
<li>如果按照HashMap和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以Redis采用了一个近似的做法，就是定时每隔一段时间就随机取出若干个key，然后按照访问时间排序后，淘汰掉最不经常使用的.  </li>
<li>Redis 3.0之后又改善了算法的性能，会提供一个待淘汰候选key的pool，里面默认有16个key，按照空闲时间排好序。更新时从Redis键空间随机选择N个key，分别计算它们的空闲时间 idle，key只会在pool不满或者空闲时间大于pool里最小的时，才会进入pool，然后从pool中选择空闲时间最大的key淘汰掉。</li>
</ul>
</li>
</ul>
<h2 id="redis哨兵"><a href="#redis哨兵" class="headerlink" title="redis哨兵"></a>redis哨兵</h2><ul>
<li>Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心 客户端通知。 </li>
<li>Redis Sentinel从Redis 2.8版本开始才正式生产可用，之前版本生产不可用。 </li>
<li>尽可能在不同物理机上部署Redis Sentinel所有节点。 </li>
<li><strong>Redis Sentinel中的Sentinel节点个数应该为大于等于3且最好为奇数。</strong></li>
<li>Redis Sentinel中的数据节点与普通数据节点没有区别。</li>
<li><strong>哨兵是一个配置提供者，而不是代理。在引入哨兵之后，客户端会先连接哨兵，再获取到主节点之后，客户端会和主节点直接通信。如果发生了故障转移，哨兵会通知到客户端。所以这也需要客户端的实现对哨兵的显式支持。</strong> </li>
<li>Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余 Sentinel节点的监控。</li>
<li><strong>Redis Sentinel在对节点做失败判定时分为主观下线和客观下线。</strong></li>
<li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis 数据节点的状态变化。 </li>
</ul>
<p>用文字描述一下故障切换（failover）的过程:</p>
<ul>
<li>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。</li>
<li>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，就对这个主节点故障达成一致, 这个过程称为<strong>客观下线</strong>。</li>
<li>这样对于客户端而言，一切都是透明的。然后通过<strong>raft算法</strong>从哨兵中选出一个哨兵来执行<strong>故障转移</strong></li>
</ul>
<h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。<br>集群模式有以下几个特点：</p>
<ul>
<li>由多个Redis服务器组成的分布式网络服务集群；</li>
<li>集群之中有多个Master主节点，每一个主节点都可读可写；</li>
<li>节点之间会互相通信，两两相连, 采用gossip协议来通信；</li>
<li>Redis集群无中心节点。</li>
<li>集群的伸缩本质是: 槽数据在节点中的移动</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在哨兵模式中，仍然只有一个Master节点。当并发写请求较大时，哨兵模式并不能缓解写压力。 我们知道只有主节点才具有写能力，那如果在一个集群中，能够配置多个主节点，缓解写压力，redis-cluster集群模式能达到此类要求。</p>
<p>在Redis-Cluster集群中，可以给每一个主节点添加从节点，主节点和从节点直接遵循主从模型的特性。<br>当用户需要处理更多读请求的时候，添加从节点开启read-only来读写分离可以扩展系统的读性能。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</li>
<li>不能用redis事务机制(不过就算不用redis集群一般也不推荐用redis的事务, 毕竟假事务无法回滚嘛, 比如multi之后那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。)。因为一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。</li>
</ul>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>Redis集群的主节点内置了类似Redis Sentinel的节点故障检测和自动故障转移功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并对已下线的主节点进行故障转移。<br>集群进行故障转移的方法和Redis Sentinel进行故障转移的方法基本一样(也有<code>主观下线</code>和<code>客观下线</code>)，不同的是，在集群里面，故障转移的过程是:</p>
<ol>
<li>在集群内广播选举消息</li>
<li>集群中其他在线的持有槽的主节点投票到故障主节点的从节点们</li>
<li>被选出来的从节点变成主节点</li>
</ol>
<p>所以集群不必另外使用Redis Sentinel。</p>
<h3 id="集群分片策略"><a href="#集群分片策略" class="headerlink" title="集群分片策略"></a>集群分片策略</h3><p>常见的集群分片算法有：</p>
<ul>
<li>一般哈希算法</li>
<li>一致性哈希算法</li>
<li>Hash Slot算法</li>
</ul>
<p>Redis采用的是Hash Slot</p>
<h4 id="一般哈希算法"><a href="#一般哈希算法" class="headerlink" title="一般哈希算法"></a>一般哈希算法</h4><p>计算方式：hash(key)%N<br>缺点：如果增加一个redis，映射公式变成了 hash(key)%(N+1)<br>​     如果一个redis宕机了，映射公式变成了 hash(key)%(N-1)<br>​     在以上两种情况下，几乎所有的缓存都失效了。</p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>先构造出一个长度为2^32整数环，根据节点名称的hash值（分布在[0,2^32-1]）放到这个环上。现在要存放资源，根据资源的Key的Hash值（也是分布在[0,2^32-1]），在环上顺时针的找到离它最近的一个节点，就建立了资源和节点的映射关系。</p>
<ul>
<li>优点：一个节点宕机时，上面的数据转移到顺时针的下一个节点中，新增一个节点时，也只需要将部分数据迁移到这个节点中，对其他节点的影响很小</li>
<li>缺点：由于数据在环上分布不均，可能存在某个节点存储的数据比较多，那么当他宕机的时候，会导致大量数据涌入下一个节点中，把另一个节点打挂了，然后所有节点都挂了</li>
<li>改进：引进了虚拟节点的概念，想象在这个环上有很多“虚拟节点”，数据的存储是沿着环的顺时针方向找一个虚拟节点，每个虚拟节点都会关联到一个真实节点</li>
</ul>
<h4 id="HashSlot算法"><a href="#HashSlot算法" class="headerlink" title="HashSlot算法"></a>HashSlot算法</h4><p>Redis采用的是Hash Slot分片算法，用来计算key存储位置的。集群将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=CRC16(key)%16384，其中CRC16为16位的循环冗余校验和函数。<br><strong>客户端可能会挑选任意一个redis实例去发送命令，每个redis实例接收到命令，都会计算key对应的hash slot，如果在本地就在本地处理，否则返回moved给客户端，让客户端进行重定向到对应的节点执行命令(实现得好一点的smart客户端会缓存键-slot-节点的映射关系来获得性能提升).</strong></p>
<p><strong>那为什么是16384个槽呢?</strong></p>
<p>ps:CRC16算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod65536，而选择mod16384？<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fantirez%2Fredis%2Fissues%2F2576" target="_blank" rel="noopener">作者解答</a></p>
<p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是<code>2k（2 * 8 (8 bit) * 1024(1k) = 2K）</code>，也就是说使用2k的空间创建了16k的槽数。</p>
<p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是<code>8k（8 * 8 (8 bit) * 1024(1k) = 8K）</code>，也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p>
<h2 id="Cache和DB如何一致"><a href="#Cache和DB如何一致" class="headerlink" title="Cache和DB如何一致"></a>Cache和DB如何一致</h2><p>详细的请参考: <a href="https://segmentfault.com/a/1190000015804406" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015804406</a><br>本博客也有一份: <a href="/cache_db_consistency/" title="Cache和DB一致性">Cache和DB一致性</a></p>
<p>总结:</p>
<ul>
<li>使用<code>cache aside pattern</code><ul>
<li>对于读请求<br>  <img src="/img/cache_db_consistency/cache_db_consistency_9.png" alt title="读请求"><br>  先读 cache，再读 db<br>  如果，cache hit，则直接返回数据<br>  如果，cache miss，则访问 db，并将数据 set 回缓存</li>
<li>对于写请求<br>  <img src="/img/cache_db_consistency/cache_db_consistency_1.png" alt title="写请求"><br>  先操作数据库，再淘汰缓存（淘汰缓存，而不是更新缓存, 如果更新缓存，在并发写时，可能出现数据不一致。）</li>
</ul>
</li>
<li>Cache Aside Pattern 方案存在什么问题？<ul>
<li><strong>问题1</strong>: 如果先写数据库，再淘汰缓存，在原子性被破坏时：<ol>
<li>修改数据库成功了</li>
<li>淘汰缓存失败了<br>导致，数据库与缓存的数据不一致。</li>
</ol>
<ul>
<li>如何解决问题1?<ul>
<li>在淘汰缓存的时候，如果失败，则重试一定的次数。如果失败一定次数还不行，那就是其他原因了。比如说 redis 故障、内网出了问题。</li>
</ul>
</li>
</ul>
</li>
<li><strong>问题2</strong>: 主从同步延迟导致的缓存和数据不一致问题<ul>
<li>问题: 发生写请求后（不管是先操作 DB，还是先淘汰 Cache），在主从数据库同步完成之前，如果有读请求，都可能发生读 Cache Miss，读从库把旧数据存入缓存的情况。此时怎么办呢？</li>
<li>解决思路: 在主从时延的时间段内，读取修改过的数据的话，强制读主，并且更新缓存，这样子缓存内的数据就是最新。在主从时延过后，这部分数据继续读从库，从而继续利用从库提高读取能力。</li>
<li>具体解决方案: <ul>
<li>写请求发生的时候: 将哪个库，哪个表，哪个主键三个信息拼装一个 key 设置到 cache 里，这条记录的超时时间，设置为 “主从同步时延”, PS：key 的格式为 “db:table:PK”，假设主从延时为 1s，这个 key 的 cache 超时时间也为 1s。</li>
<li>当读请求发生时：这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个 key，到 cache 里去查询，如果，<ul>
<li>（1）cache 里有这个 key，说明 1s 内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该去主库查询。并且把主库的数据 set 到缓存中，防止下一次 cache miss。</li>
<li>（2）cache 里没有这个 key，说明最近没有发生过写请求，此时就可以去从库查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩是啥-咋处理"><a href="#缓存雪崩是啥-咋处理" class="headerlink" title="缓存雪崩是啥?咋处理?"></a>缓存雪崩是啥?咋处理?</h2><p>是指<strong>大面积的缓存失效，打崩了DB.</strong></p>
<p>如果缓存挂掉，所有的请求会压到数据库，如果未提前做容量预估，可能会把数据库压垮（在缓存恢复之前，数据库可能一直都起不来），导致系统整体不可服务。<br>又或者打个比方, 如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住.</p>
<p>处理方案: </p>
<ul>
<li>key随机过期</li>
<li>key永不过期, 比如开个单独线程去定时更新缓存</li>
<li>高可用, 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题</li>
<li>隔离服务, 限流降级</li>
</ul>
<h2 id="缓存穿透是啥-咋处理"><a href="#缓存穿透是啥-咋处理" class="headerlink" title="缓存穿透是啥?咋处理?"></a>缓存穿透是啥?咋处理?</h2><p>是指<strong>缓存和数据库中都没有的数据，而用户不断发起请求，严重会击垮数据库</strong> </p>
<p>我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p>
<p>处理方案:</p>
<ul>
<li>缓存穿透我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截等。</li>
<li>布隆过滤器, 把存在的key提前存放好在布隆过滤器中, 当查询的时候快速判断出你这个Key是否在数据库中存在, 不存在则直接return</li>
</ul>
<h2 id="缓存击穿是啥-咋处理"><a href="#缓存击穿是啥-咋处理" class="headerlink" title="缓存击穿是啥?咋处理?"></a>缓存击穿是啥?咋处理?</h2><p>是指<strong>持续的大并发的访问一个热点数据, 当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库</strong></p>
<p>这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是缓存击穿是指一个Key非常<strong>热点</strong>，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p>
<p>处理方案:</p>
<ul>
<li>key永不过期, 比如开个单独线程去定时更新缓存</li>
<li>互斥锁, 在key失效的瞬间, 只允许一个查询操作的线程A去查询数据库并重建缓存并上互斥锁, 其他的查询操作线程全部等待线程A操作完了再从缓存里取数据</li>
</ul>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/self_cultivation_encoding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/self_cultivation_encoding/" itemprop="url">服务器开发自我修养专栏-编码知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-18T19:08:06+00:00">
                04-18-2021
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Self-cultivation/" itemprop="url" rel="index">
                    <span itemprop="name">Self-cultivation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="编码知识"><a href="#编码知识" class="headerlink" title="编码知识"></a>编码知识</h1><h2 id="Base64-的原理？编码后比编码前是大了还是小了。"><a href="#Base64-的原理？编码后比编码前是大了还是小了。" class="headerlink" title="Base64 的原理？编码后比编码前是大了还是小了。"></a>Base64 的原理？编码后比编码前是大了还是小了。</h2><p>结论:</p>
<p>大了. 因为Base64 编码本质上是一种将二进制数据转成文本数据的方案。<strong>对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（2 的 6 次方 = 64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。</strong>也就是说, 每 3 个原始字符编码成 4 个字符，如果原始字符串长度不能被 3 整除，那怎么办？使用 0 值来补充原始字符串。</p>
<h3 id="base64的原理"><a href="#base64的原理" class="headerlink" title="base64的原理"></a>base64的原理</h3><p>Base64 编码之所以称为 Base64，是因为其使用 64 个字符来对任意数据进行编码，同理有 Base32、Base16 编码。标准 Base64 编码使用的 64 个字符为：<br><img src="/img/noodle_plan/http/XHFMRvxfez4OVtr.jpg" alt></p>
<p>这 64 个字符是各种字符编码（比如 ASCII 编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64 编码又有很多变种，比如 Base64 URL 编码。</p>
<p>Base64 编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（2 的 6 次方 = 64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。</p>
<p>假设我们要对 <code>Hello!</code> 进行 Base64 编码，按照 ASCII 表，其转换过程如下图所示：<br><img src="/img/noodle_plan/http/tJnClQsjc4WMGhB.jpg" alt></p>
<p>可知 <code>Hello!</code> 的 Base64 编码结果为 <code>SGVsbG8h</code> ，原始字符串长度为 6 个字符，编码后长度为 8 个字符，每 3 个原始字符经 Base64 编码成 4 个字符，编码前后长度比 4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64 应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。</p>
<p>是不是觉得 Base64 编码原理很简单？</p>
<p>但这里需要注意一个点：Base64 编码是每 3 个原始字符编码成 4 个字符，如果原始字符串长度不能被 3 整除，那怎么办？使用 0 值来补充原始字符串。</p>
<p>以 <code>Hello!!</code> 为例，其转换过程为：<br><img src="/img/noodle_plan/http/5URB8nVis9ljwYe.jpg" alt></p>
<p><em>注：图表中蓝色背景的二进制 0 值是额外补充的。</em></p>
<p><code>Hello!!</code> Base64 编码的结果为 <code>SGVsbG8hIQAA</code> 。最后 2 个零值只是为了 Base64 编码而补充的，在原始字符中并没有对应的字符，那么 Base64 编码结果中的最后两个字符 <code>AA</code> 实际不带有效信息，所以需要特殊处理，以免解码错误。</p>
<p>标准 Base64 编码通常用 <code>=</code> 字符来替换最后的 <code>A</code>，即编码结果为 <code>SGVsbG8hIQ==</code>。因为 <code>=</code> 字符并不在 Base64 编码索引表中，其意义在于结束符号，在 Base64 解码时遇到 <code>=</code> 时即可知道一个 Base64 编码字符串结束。</p>
<p>如果 Base64 编码字符串不会相互拼接再传输，那么最后的 <code>=</code> 也可以省略，解码时如果发现 Base64 编码字符串长度不能被 4 整除，则先补充 <code>=</code> 字符，再解码即可。</p>
<p>解码是对编码的逆向操作，但注意一点：<strong>对于最后的两个 <code>=</code> 字符，转换成两个 <code>A</code> 字符，再转成对应的两个 6 比特二进制 0 值，接着转成原始字符之前，需要将最后的两个 6 比特二进制 0 值丢弃，因为它们实际上不携带有效信息</strong>。</p>
<h2 id="utf8编码和unicode字符集"><a href="#utf8编码和unicode字符集" class="headerlink" title="utf8编码和unicode字符集"></a>utf8编码和unicode字符集</h2><p>总结:  </p>
<ul>
<li>unicode是个字符集, 只是一个符号对应表, 它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li>
<li>utf8是unicode符号具体的编码方式, 规定了该怎么存储</li>
</ul>
<p>说到utf8，就不得不说一下unicode了。  Unicode是一个很大的集合，每一个unicode对应一个符号，不管是中文的汉字，英文字符，日文，韩文等等。现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</p>
<p><strong>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</strong></p>
<p>比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是：如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是：我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：</p>
<p>1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。</p>
<p>2）unicode在很长一段时间内无法推广，直到互联网的出现。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条：</p>
<ul>
<li><p>1）对于单字节的符号，字节的第一位（字节的最高位）设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
</li>
<li><p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</li>
</ul>
<p>下表总结了编码规则，字母x表示可用编码的位。</p>
<p>Unicode符号范围 UTF-8编码方式(十六进制) | （二进制）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">—————+———————————————————————</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></p>
<p>下面，还是以汉字“严”为例，演示如何实现UTF-8编码：<br>已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Mike">
          </a>
          <p class="site-author-name" itemprop="name">Mike</p>
           
              <p class="site-description motion-element" itemprop="description">🚙 🚗 💨 💨 If you want to create a blog like this, just follow my open-source project, "hexo-theme-neo", click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari, or Edge to read this blog since this blog was developed on Edge (Chromium kernel version) and tested on Safari.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">283</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">105</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">about</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/no5ix" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://open.spotify.com/user/313duq77ekebrfyak3xijqewzss4?si=e7653b829a9747bf" target="_blank" title="Spotify">
                  
                    <i class="fa fa-fw fa-spotify"></i>
                  
                    
                      Spotify
                    
                </a>
              </span>
            
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        

        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mike</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  















  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/mediumzoom/medium-zoom.js?v=1.1.0"></script>




  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

    <script src="/js/src/local-search.js"></script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>






<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/code-highlight-modification.js"></script>
